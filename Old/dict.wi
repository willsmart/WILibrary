//"<UIKit/UIKit.h>"
"<Foundation/Foundation.h>"







type UnpackedWord "typedef:struct {unsigned short blockLength;unsigned short *addr;char letters[MAXWORDLEN],word[MAXWORDLEN];int numLetters,wordLen;double freq;}"


Globals
    -top:iface
        #define NUMLETTERS 26
        #define LASTLETTER (NUMLETTERS-1)
        #define NUMLENGTHS 25
        #define LASTLENGTH (NUMLENGTHS-1)
        #define MAXWORDLEN 128
        #define MAXSEARCHLETTERS 40








Globals
    -interfaces {

        //#define DEBUGCT




        #define IP(__mi,__l,__r) ((IPVAR)<(IPARR(__mi))?(__l):(__r))
        #define IP1(__mi) IP(__mi,__mi,__mi+1)
        #define IP2(__mi) IP((__mi)+1,IP1(__mi),(__mi)+2)
        #define IP3(__mi) IP((__mi)+1,IP1(__mi),IP1((__mi)+2))
        #define IP4(__mi) IP((__mi)+2,IP2(__mi),IP1((__mi)+3))
        #define IP5(__mi) IP((__mi)+2,IP2(__mi),IP2((__mi)+3))
        #define IP6(__mi) IP((__mi)+3,IP3(__mi),IP2((__mi)+4))
        #define IP7(__mi) IP((__mi)+3,IP3(__mi),IP3((__mi)+4))
        #define IP8(__mi) IP((__mi)+4,IP4(__mi),IP3((__mi)+5))
        #define IP9(__mi) IP((__mi)+4,IP4(__mi),IP4((__mi)+5))
        #define IP10(__mi) IP((__mi)+5,IP5(__mi),IP4((__mi)+6))
        #define IP11(__mi) IP((__mi)+5,IP5(__mi),IP5((__mi)+6))
        #define IP12(__mi) IP((__mi)+6,IP6(__mi),IP5((__mi)+7))
        #define IP13(__mi) IP((__mi)+6,IP6(__mi),IP6((__mi)+7))
        #define IP14(__mi) IP((__mi)+7,IP7(__mi),IP6((__mi)+8))
        #define IP15(__mi) IP((__mi)+7,IP7(__mi),IP7((__mi)+8))
        #define IP16(__mi) IP((__mi)+8,IP8(__mi),IP7((__mi)+9))
        #define IP17(__mi) IP((__mi)+8,IP8(__mi),IP8((__mi)+9))
        #define IP18(__mi) IP((__mi)+9,IP9(__mi),IP8((__mi)+10))
        #define IP19(__mi) IP((__mi)+9,IP9(__mi),IP9((__mi)+10))
        #define IP20(__mi) IP((__mi)+10,IP10(__mi),IP9((__mi)+11))
        #define IP21(__mi) IP((__mi)+10,IP10(__mi),IP10((__mi)+11))
        #define IP22(__mi) IP((__mi)+11,IP11(__mi),IP10((__mi)+12))
        #define IP23(__mi) IP((__mi)+11,IP11(__mi),IP11((__mi)+12))
        #define IP24(__mi) IP((__mi)+12,IP12(__mi),IP11((__mi)+13))
        #define IP25(__mi) IP((__mi)+12,IP12(__mi),IP12((__mi)+13))
        #define IP26(__mi) IP((__mi)+13,IP13(__mi),IP12((__mi)+14))
        #define IP27(__mi) IP((__mi)+13,IP13(__mi),IP13((__mi)+14))
        #define IP28(__mi) IP((__mi)+14,IP14(__mi),IP13((__mi)+15))
        #define IP29(__mi) IP((__mi)+14,IP14(__mi),IP14((__mi)+15))
        #define IP30(__mi) IP((__mi)+15,IP15(__mi),IP14((__mi)+16))
        #define IP31(__mi) IP((__mi)+15,IP15(__mi),IP15((__mi)+16))

        #define INSERTPOS1 IP1(0)
        #define INSERTPOS2 IP2(0)
        #define INSERTPOS3 IP3(0)
        #define INSERTPOS4 IP4(0)
        #define INSERTPOS5 IP5(0)
        #define INSERTPOS6 IP6(0)
        #define INSERTPOS7 IP7(0)
        #define INSERTPOS8 IP8(0)
        #define INSERTPOS9 IP9(0)
        #define INSERTPOS10 IP10(0)
        #define INSERTPOS11 IP11(0)
        #define INSERTPOS12 IP12(0)
        #define INSERTPOS13 IP13(0)
        #define INSERTPOS14 IP14(0)
        #define INSERTPOS15 IP15(0)
        #define INSERTPOS16 IP16(0)
        #define INSERTPOS17 IP17(0)
        #define INSERTPOS18 IP18(0)
        #define INSERTPOS19 IP19(0)
        #define INSERTPOS20 IP20(0)
        #define INSERTPOS21 IP21(0)
        #define INSERTPOS22 IP22(0)
        #define INSERTPOS23 IP23(0)
        #define INSERTPOS24 IP24(0)
        #define INSERTPOS25 IP25(0)
        #define INSERTPOS26 IP26(0)
        #define INSERTPOS27 IP27(0)
        #define INSERTPOS28 IP28(0)
        #define INSERTPOS29 IP29(0)
        #define INSERTPOS30 IP30(0)
        #define INSERTPOS31 IP31(0)


        #define INSERTPOSn(__n,__to) { \
        int mn=-1,mx=(__n);while (mx>mn+1) { \
        (__to)=(mx+mn)>>1; \
        if ((IPVAR)<=(IPARR(__to))) mx=(__to); \
        else mn=(__to); \
        } \
        (__to)=mx; \
        }

        #define INSERTPOS(__n,__to) \
        switch (__n) { \
        case 0:__to=0;break; \
        case 1:__to=INSERTPOS1;break; \
        case 2:__to=INSERTPOS2;break; \
        case 3:__to=INSERTPOS3;break; \
        case 4:__to=INSERTPOS4;break; \
        case 5:__to=INSERTPOS5;break; \
        case 6:__to=INSERTPOS6;break; \
        case 7:__to=INSERTPOS7;break; \
        case 8:__to=INSERTPOS8;break; \
        case 9:__to=INSERTPOS9;break; \
        case 10:__to=INSERTPOS10;break; \
        case 11:__to=INSERTPOS11;break; \
        case 12:__to=INSERTPOS12;break; \
        case 13:__to=INSERTPOS13;break; \
        case 14:__to=INSERTPOS14;break; \
        case 15:__to=INSERTPOS15;break; \
        case 16:__to=INSERTPOS16;break; \
        case 17:__to=INSERTPOS17;break; \
        case 18:__to=INSERTPOS18;break; \
        case 19:__to=INSERTPOS19;break; \
        case 20:__to=INSERTPOS20;break; \
        case 21:__to=INSERTPOS21;break; \
        case 22:__to=INSERTPOS22;break; \
        case 23:__to=INSERTPOS23;break; \
        case 24:__to=INSERTPOS24;break; \
        case 25:__to=INSERTPOS25;break; \
        default:INSERTPOSn(__n,__to);break; \
        } \




        #define nextWordAddress(__ps) ((__ps)+((*(__ps))&0x1f))
        #define wordAddressFirstLetter(__ps) (letter5[((*(__ps))>>(((*ps)&0x3e0)==0x20?10:5))&0x1f])
        #define wordAddressFreq(__ps,__ret) { \
            (*(int*)&__ret)=(((int)(__ps)[((*(__ps))&0x1f)-2])<<16)|(__ps)[((*(__ps))&0x1f)-1]; \
        }

        extern const char char5[32];
        extern const char letter5[32];

        extern char g_usToLetter[3][0x10000];
        extern char g_addps[3][0x10000];
        extern char g_nxtshft[3][0x10000];



        #define NEXTLETTER(__letter,__ps,__shft,__tmpc) { \
            while ((__letter=g_usToLetter[__shft][*__ps])==30) {__ps++;__shft=0;} \
            __tmpc=g_nxtshft[__shft][*__ps]; \
            __ps+=g_addps[__shft][*__ps]; \
            __shft=__tmpc; \
        }

        const char char5[32]={0,1,'-','\'',-1,-1,'a','b','c','d','e','f','g','h','i','j'
            ,'k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};
        const char letter5[32]={-1,-2,-3,-4,-10,-10,0,1,2,3,4,5,6,7,8,9,
            10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25};

        char g_usToLetter[3][0x10000],g_addps[3][0x10000],g_nxtshft[3][0x10000];


            void setUpWords() {
                for (char shft=0;shft<3;shft++) {
                    for (int ss=0;ss<0x10000;ss++) {
                        int s=(shft==0?ss:(shft==1?(ss>>5)|0x0400:((ss>>10)|0x0420)));
                        char letter,addps=0,nxtshft;
                        if ((ss&0x8000)==0) {letter=31,addps=0,nxtshft=0;}
                        else if (!(s&0x1f)) {letter=31,addps=0,nxtshft=0;}
                        else if (letter5[s&0x1f]>=0) {
                            letter=letter5[s&0x1f];
                            if (letter5[(s>>5)&0x1f]>=0) nxtshft=1+shft;
                            else if (letter5[(s>>10)&0x1f]>=0) nxtshft=2+shft;
                            else {addps=1;nxtshft=0;}
                        }
                        else if (!((s>>5)&0x1f)) {letter=31,addps=0,nxtshft=0;}
                        else if (letter5[(s>>5)&0x1f]>=0) {
                            letter=letter5[(s>>5)&0x1f];
                            if (letter5[(s>>10)&0x1f]>=0) nxtshft=2+shft;
                            else {addps=1;nxtshft=0;}
                        }
                        else if (!(s&0x1f)) {letter=31,addps=0,nxtshft=0;}
                        else if (letter5[(s>>10)&0x1f]>=0) {
                            letter=letter5[(s>>10)&0x1f];
                            addps=1;nxtshft=0;
                        }
                        else {
                            letter=30;
                            addps=1;nxtshft=0;
                        }
                        g_usToLetter[shft][ss]=letter;
                        g_addps[shft][ss]=addps;
                        g_nxtshft[shft][ss]=nxtshft;
                    }
                }
            }



            NSString *verifyWord(unsigned short *ps) {
                unsigned short *nxt=nextWordAddress(ps);
                char letter=wordAddressFirstLetter(ps);
                if (letter<0) return(@"Bad first letter");
                
                float f;wordAddressFreq(ps,f);
                if (f<=0) return(@"Freq not pve");
                
                unsigned char shift=5;
                do {
                    if (!(*ps&0x8000)) return(@"expected top bit");
                    letter=letter5[((*ps)>>shift)&0x1f];
                    if (letter==-1) {ps++;break;}
                    else if (letter==-10) return(@"bad letter");
                    if ((shift+=5)==15) {shift=0;ps++;}
                } while ((*ps&0x8000)&&(letter!=-1));
                if (*ps&0x8000) return(@"expected no top bit");
                ps+=2;
                if (ps!=nxt) return(@"Next not same");
                return(nil);
            }


            void verifyWords(unsigned short *ps,unsigned short *eps) {
                int wi=0,nerr=0;
                while (ps<eps) {
                    wi++;
                    NSString *err=verifyWord(ps);
                    if (err) {
                        NSLog(@"Error in verify word #%d : %@\n",wi,err);nerr++;if (nerr>=100) break;
                    }
                    ps=nextWordAddress(ps);
                }
                if ((nerr<100)&&(ps!=eps)) {NSLog(@"Error in verify : wrong end\n");nerr++;}
                if (nerr) {
                    [NSException raise:@"Word list verify failed" format:@"See log (%d errors)",nerr];
                }
            }



            #define NXTSHIFT {ps+=shift/10;shift=(shift+5)%15;}



            #define ADDERFORUNLIKELIES 0




















            bool wordMatchProbabilityIsNonZero(unsigned short *ps,int numTaps,float **probByTapByLetter) {
                if (numTaps==0) return(NO);
                unsigned char shift=(((*ps)&0x3e0)==0x20?10:5);
                
                if (probByTapByLetter[letter5[((*ps)>>shift)&0x1f]][0]<1.e-10f) return(NO);
                if (numTaps==1) return(YES);
                
                if ((shift+=5)==15) {shift=0;ps++;}

                char letter;
                unsigned char tapi=1;
                
                do {
                    if ((letter=letter5[((*ps)>>shift)&0x1f])>=0) {
                        if ((probByTapByLetter[letter][tapi]>=1.e-10f)&&((++tapi)==numTaps)) return(YES);
                    }
                    if ((shift+=5)==15) {shift=0;ps++;}
                } while ((*ps&0x8000)&&(letter!=-1));
                return(NO);
            }








            UnpackedWord *unpackWordLetters(unsigned short **pps,UnpackedWord *ret) {
                *ret->word=0;
                ret->wordLen=0;

                char *lets=ret->letters;
                unsigned short *ps=ret->addr=*pps;
                unsigned short shft=5;
                do {
                    switch ((*lets)=letter5[((*ps)>>shft)&0x1f]) {
                        case -1:case -2:case -3:case -4:break;
                        case -10:[NSException raise:@"Invalid dictionary" format:@"Bad char"];
                        default:
                            if (lets<ret->letters+MAXWORDLEN-1) *(++lets)=0;
                            break;
                    }
                    if ((shft+=5)==15) {shft=0;ps++;}
                } while ((*lets!=-1)&&((*ps)&0x8000));
                ret->numLetters=(int)(lets-ret->letters);
                if (shft) ps++;
                
                int fi=((*ps)<<16)|*(++ps);
                ret->freq=ADDERFORUNLIKELIES+*(float*)&fi;// fraction of words in sentences in the library that are this word (plus a bit)

                *pps=++ps;
                if (ps!=nextWordAddress(ret->addr)) {
                    [NSException raise:@"Invalid dictionary" format:@"Wrong word length"];
                }
                return(ret);
            }


            UnpackedWord *unpackWord(unsigned short **pps,UnpackedWord *ret) {
                char *wd=ret->word,*lets=ret->letters;
                unsigned short *ps=ret->addr=*pps;
                unsigned short shft=5,v;
                char addLetter=0;
                do {
                    switch ((*lets)=letter5[v=((*ps)>>shft)&0x1f]) {
                        case -1:break;
                        case -2:addLetter='A'-'a';break;
                        case -10:[NSException raise:@"Invalid dictionary" format:@"Bad char"];
                        case -3:case -4:
                            if (wd<ret->word+MAXWORDLEN-1) *(wd++)=char5[v];
                            break;
                        default:
                            if (lets<ret->letters+MAXWORDLEN-1) *(++lets)=0;
                            if (wd<ret->word+MAXWORDLEN-1) {*(wd++)=char5[v]+addLetter;addLetter=0;}
                            break;
                    }
                    if ((shft+=5)==15) {shft=0;ps++;}
                } while ((*lets!=-1)&&((*ps)&0x8000));
                *wd=0;
                ret->numLetters=(int)(lets-ret->letters);
                ret->wordLen=(int)(wd-ret->word);
                if (shft) ps++;
                
                int fi=((*ps)<<16)|*(++ps);
                ret->freq=ADDERFORUNLIKELIES+*(float*)&fi;// fraction of words in sentences in the library that are this word (plus a bit)
                
                *pps=++ps;
                if (ps!=nextWordAddress(ret->addr)) {
                    [NSException raise:@"Invalid dictionary" format:@"Wrong word length"];
                }
                return(ret);
            }




            bool fillLettersFromWord(UnpackedWord *wd) {
                char *wpc=wd->word,*lpc=wd->letters;
                wd->numLetters=0;
                while (*wpc) {
                    if (*wpc=='-') {
                        if (wpc==wd->word) return(NO);
            //			*lpc=2;
                    }
                    else if (*wpc=='\'') {
                        if (wpc==wd->word) return(NO);
            //			*lpc=3;
                    }
                    else if ((*wpc>='a')&&(*wpc<='z')) {
                        *(lpc++)=(*wpc)-'a';
                        wd->numLetters++;
                    }
                    else if ((*wpc>='A')&&(*wpc<='Z')) {
            //			*(lpc++)=1;
                        *(lpc++)=(*wpc)-'A';
                        wd->numLetters++;
                    }
                    else return(NO);
                    wpc++;
                }
                return(YES);
            }


            int makeUnpackedWordForFile(UnpackedWord *wd,unsigned short *buf) {
                unsigned short *ps=buf;*ps=0x8000;
                char *wpc=wd->word;
                unsigned char shift=5;
                while (*wpc) {
                    if (*wpc=='-') {
                        if (wpc==wd->word) return(0);
                        *ps|=(2<<shift);
                    }
                    else if (*wpc=='\'') {
                        if (wpc==wd->word) return(0);
                        *ps|=(3<<shift);
                    }
                    else if ((*wpc>='a')&&(*wpc<='z')) {
                        *ps|=(((*wpc)+6-'a')<<shift);
                    }
                    else if ((*wpc>='A')&&(*wpc<='Z')) {
                        *ps|=(1<<shift);
                        if ((shift+=5)==15) {*(++ps)=0x8000;shift=0;}
                        *ps|=(((*wpc)+6-'A')<<shift);
                    }
                    else return(0);
                    if ((shift+=5)==15) {*(++ps)=0x8000;shift=0;}
                    if (ps>buf+0x20) return(0);
                    wpc++;
                }
                if (shift) ps++;
                float f=wd->freq;
                *(ps++)=((unsigned short*)&f)[1];
                *(ps++)=((unsigned short*)&f)[0];
                int len=(int)(ps-buf);
                if (len>=0x1f) return(0);
                (*buf)|=len;
                return(len);
            }



            bool isLetterChar(unichar c) {return(((c>='a')&&(c<='z'))||((c>='A')&&(c<='Z')));}
            bool isWordChar(unichar c) {return(((c>='a')&&(c<='z'))||((c>='A')&&(c<='Z'))||(c=='\'')||(c=='-'));}
            bool isSpaceChar(unichar c) {return((c==' ')||(c=='\t'));}
            bool isSpaceOrNLChar(unichar c) {return((c==' ')||(c=='\t')||(c=='\r')||(c=='\n'));}
            bool isEOSentenceChar(unichar c) {return((c=='.')||(c=='!')||(c=='?'));}


        #define GOJ0 *outa=PBYTAPBYJ(i,0)* *outb
        #define GOJ(___j) outa[___j]=fmax(PBYTAPBYJ(i,___j)*outb[___j],

        #define GOJE )

        #define GOJS0 GOJ0
        #define GOJS1 GOJ(1) GOJS0 GOJE
        #define GOJS2 GOJ(2) GOJS1 GOJE
        #define GOJS3 GOJ(3) GOJS2 GOJE
        #define GOJS4 GOJ(4) GOJS3 GOJE
        #define GOJS5 GOJ(5) GOJS4 GOJE
        #define GOJS6 GOJ(6) GOJS5 GOJE
        #define GOJS7 GOJ(7) GOJS6 GOJE
        #define GOJS8 GOJ(8) GOJS7 GOJE
        #define GOJS9 GOJ(9) GOJS8 GOJE
        #define GOJS10 GOJ(10) GOJS9 GOJE
        #define GOJS11 GOJ(11) GOJS10 GOJE
        #define GOJS12 GOJ(12) GOJS11 GOJE
        #define GOJS13 GOJ(13) GOJS12 GOJE
        #define GOJS14 GOJ(14) GOJS13 GOJE
        #define GOJS15 GOJ(15) GOJS14 GOJE
        #define GOJS16 GOJ(16) GOJS15 GOJE
        #define GOJS17 GOJ(17) GOJS16 GOJE
        #define GOJS18 GOJ(18) GOJS17 GOJE
        #define GOJS19 GOJ(19) GOJS18 GOJE
        #define GOJS20 GOJ(20) GOJS19 GOJE
        #define GOJS21 GOJ(21) GOJS20 GOJE
        #define GOJS22 GOJ(22) GOJS21 GOJE
        #define GOJS23 GOJ(23) GOJS22 GOJE
        #define GOJS24 GOJ(24) GOJS23 GOJE
        #define GOJS25 GOJ(25) GOJS24 GOJE
        #define GOJS26 GOJ(26) GOJS25 GOJE
        #define GOJS27 GOJ(27) GOJS26 GOJE
        #define GOJS28 GOJ(28) GOJS27 GOJE
        #define GOJS29 GOJ(29) GOJS28 GOJE
        #define GOJS30 GOJ(30) GOJS29 GOJE
        #define GOJS(D) GOJ0;for (unsigned short __j=1;__j<=D;__j++) GOJ(__j) outa[__j-1] GOJE;


        #define GOJZ0 *outa=PBYTAPBYJ(1,0)*z
        #define GOJZ(___j) outa[___j]=fmax(PBYTAPBYJ(1,___j)*z,

        #define GOJZS0 GOJZ0
        #define GOJZS1 GOJZ(1) GOJZS0 GOJE
        #define GOJZS2 GOJZ(2) GOJZS1 GOJE
        #define GOJZS3 GOJZ(3) GOJZS2 GOJE
        #define GOJZS4 GOJZ(4) GOJZS3 GOJE
        #define GOJZS5 GOJZ(5) GOJZS4 GOJE
        #define GOJZS6 GOJZ(6) GOJZS5 GOJE
        #define GOJZS7 GOJZ(7) GOJZS6 GOJE
        #define GOJZS8 GOJZ(8) GOJZS7 GOJE
        #define GOJZS9 GOJZ(9) GOJZS8 GOJE
        #define GOJZS10 GOJZ(10) GOJZS9 GOJE
        #define GOJZS11 GOJZ(11) GOJZS10 GOJE
        #define GOJZS12 GOJZ(12) GOJZS11 GOJE
        #define GOJZS13 GOJZ(13) GOJZS12 GOJE
        #define GOJZS14 GOJZ(14) GOJZS13 GOJE
        #define GOJZS15 GOJZ(15) GOJZS14 GOJE
        #define GOJZS16 GOJZ(16) GOJZS15 GOJE
        #define GOJZS17 GOJZ(17) GOJZS16 GOJE
        #define GOJZS18 GOJZ(18) GOJZS17 GOJE
        #define GOJZS19 GOJZ(19) GOJZS18 GOJE
        #define GOJZS20 GOJZ(20) GOJZS19 GOJE
        #define GOJZS21 GOJZ(21) GOJZS20 GOJE
        #define GOJZS22 GOJZ(22) GOJZS21 GOJE
        #define GOJZS23 GOJZ(23) GOJZS22 GOJE
        #define GOJZS24 GOJZ(24) GOJZS23 GOJE
        #define GOJZS25 GOJZ(25) GOJZS24 GOJE
        #define GOJZS26 GOJZ(26) GOJZS25 GOJE
        #define GOJZS27 GOJZ(27) GOJZS26 GOJE
        #define GOJZS28 GOJZ(28) GOJZS27 GOJE
        #define GOJZS29 GOJZ(29) GOJZS28 GOJE
        #define GOJZS30 GOJZ(30) GOJZS29 GOJE
        #define GOJZS(__D) GOJZ0;for (unsigned short __j=1;__j<=__D;__j++) GOJZ(__j) outa[__j-1] GOJE;


        #define GOI \
        GOJZd;\
        for (unsigned short i=1;(i<numTaps)&&(outa[D]>bestProb);i++) { \
        tmpout=outa;outa=outb;outb=tmpout; \
        GOJd; \
        }
        #define GOID(_D) \
        GOJZS(_D);\
        for (unsigned short i=1;(i<numTaps)&&(outa[D]>bestProb);i++) { \
        tmpout=outa;outa=outb;outb=tmpout; \
        GOJS(_D); \
        }


        #define MAXTAPS 1000
        static float *letterPs[MAXTAPS];
        static float souta[2][MAXTAPS],*outa,*outb,*tmpout;
        #define PBYTAPBYJ(_tapi,_jj) (letterPs[_jj+_tapi][_tapi])

        static inline float goi(unsigned short D,unsigned short numTaps,float z,float bestProb) {
            outa=souta[0];
            outb=souta[1];
            switch (D) {
                case 0:
        #define GOJZd GOJZS0
        #define GOJd GOJS0
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 1:
        #define GOJZd GOJZS1
        #define GOJd GOJS1
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 2:
        #define GOJZd GOJZS2
        #define GOJd GOJS2
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 3:
        #define GOJZd GOJZS3
        #define GOJd GOJS3
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 4:
        #define GOJZd GOJZS4
        #define GOJd GOJS4
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 5:
        #define GOJZd GOJZS5
        #define GOJd GOJS5
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 6:
        #define GOJZd GOJZS6
        #define GOJd GOJS6
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 7:
        #define GOJZd GOJZS7
        #define GOJd GOJS7
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 8:
        #define GOJZd GOJZS8
        #define GOJd GOJS8
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 9:
        #define GOJZd GOJZS9
        #define GOJd GOJS9
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                    
                    
                    
                    
                    
                case 10:
        #define GOJZd GOJZS10
        #define GOJd GOJS10
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 11:
        #define GOJZd GOJZS11
        #define GOJd GOJS11
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 12:
        #define GOJZd GOJZS12
        #define GOJd GOJS12
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 13:
        #define GOJZd GOJZS13
        #define GOJd GOJS13
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 14:
        #define GOJZd GOJZS14
        #define GOJd GOJS14
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 15:
        #define GOJZd GOJZS15
        #define GOJd GOJS15
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 16:
        #define GOJZd GOJZS16
        #define GOJd GOJS16
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 17:
        #define GOJZd GOJZS17
        #define GOJd GOJS17
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 18:
        #define GOJZd GOJZS18
        #define GOJd GOJS18
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 19:
        #define GOJZd GOJZS19
        #define GOJd GOJS19
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                    
                    
                    
                    
                    
                case 20:
        #define GOJZd GOJZS20
        #define GOJd GOJS20
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 21:
        #define GOJZd GOJZS21
        #define GOJd GOJS21
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 22:
        #define GOJZd GOJZS22
        #define GOJd GOJS22
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 23:
        #define GOJZd GOJZS23
        #define GOJd GOJS23
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 24:
        #define GOJZd GOJZS24
        #define GOJd GOJS24
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 25:
        #define GOJZd GOJZS25
        #define GOJd GOJS25
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 26:
        #define GOJZd GOJZS26
        #define GOJd GOJS26
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 27:
        #define GOJZd GOJZS27
        #define GOJd GOJS27
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 28:
        #define GOJZd GOJZS28
        #define GOJd GOJS28
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 29:
        #define GOJZd GOJZS29
        #define GOJd GOJS29
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                case 30:
        #define GOJZd GOJZS30
        #define GOJd GOJS30
                    GOI
                    return(outa[D]);
        #undef GOJZd
        #undef GOJd
                    
                default:
                    GOID(D)
                    return(outa[D]);
            }
        }








        //#define DEBTAPPROB


        float wordMatchProbability(unsigned short *ps,int numTaps,float **probByTapByLetter,float z,float bestProb) {
        #ifdef DEBTAPPROB
            UnpackedWord wd;
            unsigned short *ps2=ps;
            unpackWord(&ps2, &wd);
            if (!strcmp(wd.word,"text")) {
                int k=0;
                k=1;
            }
            if (!strcmp(wd.word,"txt")) {
                int k=0;
                k=1;
            }
            char word[1000];
            memset(word,0,sizeof(word));
        #endif
            
            //if ((numTaps<=0)||(z<=bestProb)) return(-1);
            
            unsigned char shft=1,letter,tmpc;

            NEXTLETTER(letter,ps,shft,tmpc);
            
        #ifdef DEBTAPPROB
            word[0]=letter+'a';
        #endif
            
            if ((z*=probByTapByLetter[letter][0])<=bestProb) return(-1);
            
            if (numTaps==1) return(z);
            
            unsigned char numLetters=1,tapi=1;
            do {
                NEXTLETTER(letter,ps,shft,tmpc);
                if (letter==31) return(-1);
        #ifdef DEBTAPPROB
                word[numLetters]=letter+'a';
        #endif
            } while (((letterPs[numLetters++]=probByTapByLetter[letter])[tapi]<1.e-10f)||((++tapi)<numTaps));
            
            while (true) {
                NEXTLETTER(letter,ps,shft,tmpc);
        #ifdef DEBTAPPROB
                word[numLetters]=letter+'a';
        #endif
                if (letter==31) break;
                else letterPs[numLetters++]=probByTapByLetter[letter];
            }

            float ret;
            return((ret=goi(numLetters-numTaps,numTaps,z,bestProb))>bestProb?ret:-1);
        }



    }// interfaces









DictionaryWord
    NSString word=nil (ivar=word)
    double wordFreq=nil
    double _calculatedProb=nil


    double calculatedProb=
        {return(self._calculatedProb);}
        -v{
            Dictionary *dict=[Dictionary getDefault];
            if (v>0) {
                [dict addWord:self.word freq:v/self.calculatedProb freqIsMultiplier:true];
            }
            else {
                [dict removeWord:self.word];
            }
        }



    - (init[super init])initWithUnpackedWord:(UnpackedWord)wd calculatedProb:(double)prob {
        self.word=[NSString stringWithFormat:@"%s",wd.word];
        wordFreq=wd.freq;
        self._calculatedProb=prob;
        return(self);
    }


    - (init[super init])initWithWord:(NSString*)aword {
        self.word=aword;
        self._calculatedProb=wordFreq=-1;
        return(self);
    }

    - (bool)removeWord {
        return([[Dictionary getDefault] removeWord:self.word]);
    }

    - (bool)addWord {
        return([[Dictionary getDefault] addWord:self.word freq:self.wordFreq freqIsMultiplier:false]);
    }










Globals
    -interfaces
        static Dictionary *_Dictionary_default=nil;


Dictionary

    bool needLastLetter=NO
    double missingMul=0.15
    double maxWordLengthMul=3
    double maxPotentials=1000000
    double minFreq=0

    +(Dictionary*)getDefault {
        if (!_Dictionary_default) {
            ADDSINGLETON(_Dictionary_default=[[Dictionary alloc] init]);
        }
        return(_Dictionary_default);
    }


    NSMutableArray dictsForLengths=[NSMutableArray array] (readonly,dealloc,ivar=dictsForLengths)
    bool changed=NO,inited=NO

    NSString dictPath={
        NSArray *paths = NSSearchPathForDirectoriesInDomains( NSDocumentDirectory, NSUserDomainMask ,YES );
        NSString *documentsDirectory = [paths objectAtIndex:0];
        return([documentsDirectory stringByAppendingPathComponent:[NSString stringWithFormat:@"a.dict"]]);
    }


    - (void)saveIfRequired {if (changed) [self saveToFile:self.dictPath];}

    -(void)initDicts {
        [self.dictsForLengths removeAllObjects];
        for (int len=1;len<128;len++) {
            [self.dictsForLengths addObject:[NSNull null]];
        }
    }
        
    -(init) {
        [self initDicts];
    }

    -(init)init {}

    -(void)load {
        if (![self loadFromFile:self.dictPath]) {
            [self loadFromResource:@"wc3c4"];
            [self saveToFile:self.dictPath];
		}
	}

    - (void)revert {
        [[NSFileManager defaultManager] removeItemAtPath:self.dictPath error:nil];
        [self load];
        
        //[[[UIAlertView alloc] initWithTitle:[NSString stringWithFormat:@"The dictionary has been reverted to the one that came with clumsy thums"]
          //                           message:nil
          //                          delegate:nil
          //                 cancelButtonTitle:@"OK"
          //                 otherButtonTitles:nil] show];
    }


    - (void)setFromPreferences {
        NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
        [defaults synchronize];
        //NSString *s=[defaults stringForKey:@"multi_numWords"];
        //self.numWords=s?atoi([s UTF8String]):200000;
        //s=[defaults stringForKey:@"multi_missed"];
        //self.maxWordLengthMul=(s?atof([s UTF8String]):1.5);
        if ([defaults.dictionaryRepresentation objectForKey:@"toggle_revertdict"]==nil?NO:[defaults boolForKey:@"toggle_revertdict"]) {
            [defaults setBool:NO forKey:@"toggle_revertdict"];
            [defaults synchronize];
            
            
            [self revert];
        }
        
        //[[Dictionary getDefault] findMinFreq];
    }















    - (unsigned short*)dictStartForLength:(int)len {
        return((unsigned short*)[(NSMutableData*)[dictsForLengths objectAtIndex:len] mutableBytes]);
    }
    - (unsigned short*)dictEndForLength:(int)len {
        return((unsigned short*)(((BYT*)[(NSMutableData*)[dictsForLengths objectAtIndex:len] mutableBytes])+((NSMutableData*)[dictsForLengths objectAtIndex:len]).length));
    }










    //#define MINLETTERMUL (1.e-50)


    - (bool)loadFromResource:(NSString*)resource {
        return([self loadFromFile:[[NSBundle mainBundle] pathForResource:resource ofType:@"dict"]]);
    }


    - (bool)loadFromFile:(NSString*)path {
        @synchronized (self) {
            inited=YES;
            changed=NO;
            
            [self initDicts];
            
            needLastLetter=NO;
            missingMul=0.15;
            maxWordLengthMul=3;
            maxPotentials=0x1000000;//2000;
            minFreq=0;
            
            
            if (sizeof(char)!=1) [NSException raise:@"Insanity" format:@"sizeof(char)!=1"];
            if (sizeof(short)!=2) [NSException raise:@"Insanity" format:@"sizeof(short)!=2"];
            if (sizeof(int)!=4) [NSException raise:@"Insanity" format:@"sizeof(int)!=4"];
            int i=1;
            if ((*(char*)&i)!=1) [NSException raise:@"Insanity" format:@"bigendian"];
            
            FILE *fil=fopen([path UTF8String],"rb");
            if (fil==nil) return(NO);
            //	int wordCount=0;
            @try {
                if (fread(&i,sizeof(int),1,fil)!=1) [NSException raise:@"Invalid dictionary" format:@"empty"];
                if (i!=1234567894) [NSException raise:@"Invalid dictionary" format:@"Not a dictionary, or incorrect version"];
                
                int fileSize=0;
                if (fread(&fileSize,sizeof(int),1,fil)!=1) [NSException raise:@"Invalid dictionary" format:@"no fileSize"];
                if (fileSize<=15) [NSException raise:@"Invalid dictionary" format:@"Bad fileSize"];
                
                char numTypes[3]={0,0,0};
                if (fread(numTypes,sizeof(char),3,fil)!=3) [NSException raise:@"Invalid dictionary" format:@"no type nums"];
                if ((numTypes[0]!=1)||(numTypes[1]!=1)||(numTypes[2]!=NUMLENGTHS)) {
                    [NSException raise:@"Invalid dictionary" format:@"Wrong letter/length counts"];
                }
                
                int wordBlocksSize=0;
                if (fread(&wordBlocksSize,sizeof(int),1,fil)!=1) [NSException raise:@"Invalid dictionary" format:@"no wordBlocksSize"];
                if (wordBlocksSize<0) [NSException raise:@"Invalid dictionary" format:@"Bad wordBlocksSize"];
                
                int wordsOfLengthStartIndexes[NUMLENGTHS];
                int wordsOfLengthByteCounts[NUMLENGTHS];
                
                if (fread(&wordsOfLengthStartIndexes[0],sizeof(int),NUMLENGTHS,fil)!=NUMLENGTHS) {
                    [NSException raise:@"Invalid dictionary" format:@"Not enough block starts"];
                }
                
                if (fread(&wordsOfLengthByteCounts[0],sizeof(int),NUMLENGTHS,fil)!=NUMLENGTHS) {
                    [NSException raise:@"Invalid dictionary" format:@"Not enough block len"];
                }
                
                for (int len=0;len<NUMLENGTHS;len++) {
                    NSMutableData *dict=[NSMutableData dataWithLength:wordsOfLengthByteCounts[len]];
                    if (fread([dict mutableBytes],1,wordsOfLengthByteCounts[len],fil)!=wordsOfLengthByteCounts[len]) {
                        [NSException raise:@"Invalid dictionary" format:@"Not enough word bytes for length %d",len];
                    }
                    [dictsForLengths replaceObjectAtIndex:len withObject:dict];
                }
                
                [self verifyOrAlert];
                
                [self findMinFreq];
            }
            @finally {
                fclose(fil);
            }
        }		
        return(YES);
    }


    - (bool)saveToFile:(NSString*)path {
        @synchronized (self) {
            if (![self verifyOrAlert]) return(NO);
        
            changed=NO;
            
            FILE *fil=fopen([path UTF8String],"wb");
            if (fil==nil) return(NO);
            @try {
                int i=1234567894;
                if (fwrite(&i,sizeof(int),1,fil)!=1) [NSException raise:@"Failed to save dictionary" format:@"empty"];
                
                int fileSize=0x10000;// no longer required
                if (fwrite(&fileSize,sizeof(int),1,fil)!=1) [NSException raise:@"Failed to save dictionary" format:@"no fileSize"];
                
                char numTypes[3]={1,1,NUMLENGTHS};
                if (fwrite(numTypes,sizeof(char),3,fil)!=3) [NSException raise:@"Failed to save dictionary" format:@"no type nums"];
                
                int wordBlocksSize=0x10000;// no longer required
                if (fwrite(&wordBlocksSize,sizeof(int),1,fil)!=1) [NSException raise:@"Failed to save dictionary" format:@"no wordBlocksSize"];
                if (wordBlocksSize<0) [NSException raise:@"Failed to save dictionary" format:@"Bad wordBlocksSize"];
                
                int wordsOfLengthStartIndexes[NUMLENGTHS];
                int wordsOfLengthByteCounts[NUMLENGTHS];
                
                i=0;
                for (int len=0;len<NUMLENGTHS;len++) {
                    wordsOfLengthStartIndexes[len]=i;
                    i+=(wordsOfLengthByteCounts[len]=(int)((NSMutableData*)[dictsForLengths objectAtIndex:len]).length);
                }
                
                if (fwrite(&wordsOfLengthStartIndexes[0],sizeof(int),NUMLENGTHS,fil)!=NUMLENGTHS) {
                    [NSException raise:@"Failed to save dictionary" format:@"Not enough block starts"];
                }
                
                if (fwrite(&wordsOfLengthByteCounts[0],sizeof(int),NUMLENGTHS,fil)!=NUMLENGTHS) {
                    [NSException raise:@"Failed to save dictionary" format:@"Not enough block len"];
                }
                
                for (int len=0;len<NUMLENGTHS;len++) {
                    if (fwrite([(NSMutableData*)[dictsForLengths objectAtIndex:len] mutableBytes],1,wordsOfLengthByteCounts[len],fil)!=wordsOfLengthByteCounts[len]) {
                        [NSException raise:@"Failed to save dictionary" format:@"Not enough word bytes for length %d",len];
                    }
                }
                
    //			[self verify];
                
            }
            @finally {
                fclose(fil);
            }
        }
        
        return(YES);
    }











    - (double)findMinFreq {
        unsigned short *pss[NUMLENGTHS],*epss[NUMLENGTHS];
        UnpackedWord wds[NUMLENGTHS];
        int nwds=0;
        for (int len=0;len<NUMLENGTHS;len++) {
            pss[len]=[self dictStartForLength:len];
            epss[len]=[self dictEndForLength:len];
            if (pss[len]<epss[len]) {unpackWord(&pss[len],&wds[len]);}
        }
        while (YES) {
            int mxlen=-1;
            for (int len=0;len<NUMLENGTHS;len++) if ((pss[len]<epss[len])&&((mxlen==-1)||(wds[mxlen].freq<wds[len].freq))) mxlen=len;
            if (mxlen==-1) {minFreq=0;break;}
            //if (!strcmp(wds[mxlen].word,"hieroglyphic")) {
            //	int k=0;
            //	k=1;
            //}
            if (nwds++>=self.numWords) {minFreq=wds[mxlen].freq-1.e-30;break;}
            unpackWord(&pss[mxlen],&wds[mxlen]);
        }
        return(minFreq);
    }
















    /*interfaces
        static bool inVer=NO;
    */

    - (NSString*)verify {
        NSString *ret=nil;
        @synchronized (self) {
            @try {
                for (int len=0;len<NUMLENGTHS;len++) [self verifyLength:len];
            }
            @catch (NSException * e) {
                ret=[NSString stringWithFormat:@"Exception while attempting to verify dictionary\n%@\n%@\n",[e name],[e reason]];
                NSLog(@"\n\n!!!!!%@\n\n",ret);
            }			
        }
        if (ret) {
            [self revert];
        }
        return(ret);
    }

    - (bool)verifyOrAlert {
        NSString *err=[self verify];
        if (err.length) {
            //[[[UIAlertView alloc] initWithTitle:@"Error: the dictionary was in an invalid state, and has been reloaded"
            //                             message:nil
            //                            delegate:nil
            //                   cancelButtonTitle:@"OK"
            //                   otherButtonTitles:nil] show];
            return(NO);
        }
        else return(YES);
    }


    /*interfaces
    int wordLenIndex(NSString* str) {
        int len,i;for (len=i=0;i<str.length;i++) if (isLetterChar([str characterAtIndex:i])) len++;
        if (len==0) return(-1);	
        if ((--len)>=NUMLENGTHS) len=NUMLENGTHS-1;
        return(len);
    }
    */

    - (void)verifyLength:(int)len {
        unsigned short *st=[self dictStartForLength:len],*en=[self dictEndForLength:len],*addr=st;
        UnpackedWord wd;
        double freq=1.e300;
        while ((addr>=st)&&(addr<en)) {
            unpackWord(&addr,&wd);
            if (wd.freq>freq) [NSException raise:@"Failed verify" format:@"frequency ascends at word %s",wd.word];
            freq=wd.freq;
            if ((wd.numLetters!=len+1)&&!((len>=NUMLENGTHS-1)&&(wd.numLetters>=NUMLENGTHS))) {
                [NSException raise:@"Failed verify" format:@"word %s has been put in the dict for length index %d",wd.word,len];
            }
        }
        if (addr!=en) {
            [NSException raise:@"Failed verify" format:@"Expected exact length"];
        }		
    }


    - (unsigned short*)_findWord:(NSString*)str {
        int len=wordLenIndex(str);
        if (len<0) return(nil);
        
        UnpackedWord wd;
        const char *strWord=[str UTF8String];
        unsigned short *ps=[self dictStartForLength:len],*eps=[self dictEndForLength:len];
        while (ps<eps) {
            unpackWord(&ps,&wd);
            if (!strcmp(wd.word,strWord)) return(wd.addr);
        }
        return(nil);
    }



    - (void)test:(id)progressTextView {
        srand(100);
        int numtest=10000;
        //progressTextView.text=[progressTextView.text stringByAppendingFormat:@"\n\nTesting dict..\n"];
        for (int i=0;i<numtest;i++) {
            @try {
                if (!(i%100)) {
                    NSLog(@"%d%% . ",i/100);
                    //progressTextView.text=[progressTextView.text stringByAppendingFormat:@"%d%% . ",i/100];
                    [self verifyOrAlert];
                }
                int len=rand()%NUMLENGTHS;
                unsigned short *ps=[self dictStartForLength:len],*eps=[self dictEndForLength:len];
                UnpackedWord wd,wd2;
                int numInLen=0;while (ps<eps) {unpackWord(&ps,&wd);numInLen++;}
                if (numInLen) {
                    int wdi=rand()%numInLen;
                    switch (rand()%10) {
                        case 0:wdi=0;break;
                        case 1:wdi=numInLen-1;break;
                    }
                    ps=[self dictStartForLength:len];
                    while (((wdi--)>=0)&&(ps<eps)) unpackWord(&ps,&wd);
                    NSString *wdstr=[NSString stringWithFormat:@"%s",wd.word];
                    NSLog(@"Find %@  ",wdstr);
                    if ([self _findWord:wdstr]!=wd.addr) {
                        [NSException raise:@"Dict operation failed" format:@"Could not find word"];
                    }
                    NSLog(@"remove  ");
                    if (![self removeWord:wdstr]) {
                        [NSException raise:@"Dict operation failed" format:@"Could not remove word"];
                    }
                    [self verifyLength:len];
                    if ([self _findWord:wdstr]) {
                        [NSException raise:@"Dict operation failed" format:@"Found removed word"];
                    }
                    NSLog(@"add  ");
                    if (![self addWord:wdstr freq:wd.freq freqIsMultiplier:NO]) {
                        [NSException raise:@"Dict operation failed" format:@"Could not add word"];
                    }
                    [self verifyLength:len];
                    NSLog(@"find  ");
                    ps=[self _findWord:wdstr];
                    if (!ps) {
                        [NSException raise:@"Dict operation failed" format:@"Could not find added word"];
                    }
                    unpackWord(&ps,&wd2);
                    if (wd2.freq!=wd.freq) {
                        [NSException raise:@"Dict operation failed" format:@"Added word has wrong freq"];
                    }
                }
            }
            @catch (NSException *e) {
                //progressTextView.text=[progressTextView.text stringByAppendingFormat:@"ex:%@ ",[e name]];
                NSLog(@"\nException : %@\n%@\n",[e name],[e reason]);for (NSString *s in [e callStackSymbols]) NSLog(@"%@\n",s);NSLog(@"\n");
                [self loadFromResource:@"wc3c4"];
            }
        }
        int i=0;
        i=1;
    }


    - (unsigned short*)_findFreq:(float)freq wordLengthIndex:(int)len {
        UnpackedWord wd;
        unsigned short *ps=[self dictStartForLength:len],*eps=[self dictEndForLength:len];
        while (ps<eps) {
            unpackWord(&ps,&wd);
            if (wd.freq<freq) return(wd.addr);
        }
        return(ps);
    }


    - (void)_removeBytesForLength:(int)len at:(int)at numBytes:(int)numBytes {
        if ((at<0)||(at+numBytes>((NSMutableData*)[dictsForLengths objectAtIndex:len]).length)) {
            [NSException raise:@"Invalid operation" format:@"Cannot remove bytes at [%d,%d+%d) from a data of length %lu",at,at,numBytes,((NSMutableData*)[dictsForLengths objectAtIndex:len]).length];
        }
        if (at+numBytes<((NSMutableData*)[dictsForLengths objectAtIndex:len]).length) {
            BYT *vp=((BYT*)[((NSMutableData*)[dictsForLengths objectAtIndex:len]) mutableBytes])+at;
            memmove(vp,vp+numBytes,((NSMutableData*)[dictsForLengths objectAtIndex:len]).length-(at+numBytes));
        }
        ((NSMutableData*)[dictsForLengths objectAtIndex:len]).length-=numBytes;
    }


    - (void)_addBytesForLength:(int)len at:(int)at numBytes:(int)numBytes bytes:(void*)bytes {
        if ((at<0)||(at>((NSMutableData*)[dictsForLengths objectAtIndex:len]).length)) {
            [NSException raise:@"Invalid operation" format:@"Cannot add bytes at %d to a data of length %lu",at,((NSMutableData*)[dictsForLengths objectAtIndex:len]).length];
        }
        ((NSMutableData*)[dictsForLengths objectAtIndex:len]).length+=numBytes;
        BYT *vp=((BYT*)[((NSMutableData*)[dictsForLengths objectAtIndex:len]) mutableBytes])+at;
        if (at<((NSMutableData*)[dictsForLengths objectAtIndex:len]).length) {
            memmove(vp+numBytes,vp,((NSMutableData*)[dictsForLengths objectAtIndex:len]).length-at);
        }
        memcpy(vp,bytes,numBytes);
    }


    - (void)_moveBytesForLength:(int)len from:(int)from to:(int)to numBytes:(int)numBytes bytes:(void*)newBytes {
        if ((from<0)||(from+numBytes>((NSMutableData*)[dictsForLengths objectAtIndex:len]).length)) {
            [NSException raise:@"Invalid operation" format:@"Cannot remove (in move) bytes at [%d,%d+%d) from a data of length %lu",from,from,numBytes,((NSMutableData*)[dictsForLengths objectAtIndex:len]).length];
        }
        if ((to<0)||(to>((NSMutableData*)[dictsForLengths objectAtIndex:len]).length)) {
            [NSException raise:@"Invalid operation" format:@"Cannot add (in move) bytes at %d to a data of length %lu",to,((NSMutableData*)[dictsForLengths objectAtIndex:len]).length];
        }
        BYT *tovp=((BYT*)[((NSMutableData*)[dictsForLengths objectAtIndex:len]) mutableBytes])+to;
        BYT *fromvp=((BYT*)[((NSMutableData*)[dictsForLengths objectAtIndex:len]) mutableBytes])+from;
        if ((to<from)||(to>from+numBytes)) {
            if (to>from) {
                tovp-=numBytes;
                to-=numBytes;
                memmove(fromvp,fromvp+numBytes,to-from);
            }
            else memmove(tovp+numBytes,tovp,from-to);
        }
        else {to=from;tovp=fromvp;}
        memcpy(tovp,newBytes,numBytes);
    }


    - (bool)_removeWordAtAddress:(unsigned short*)addr {
        if (addr==nil) return(NO);
        int len;
        for (len=0;len<NUMLENGTHS;len++) {
            if ((addr>=[self dictStartForLength:len])&&(addr<[self dictEndForLength:len])) break;
        }
        if (len==NUMLENGTHS) {
            [NSException raise:@"Invalid operation" format:@"The address given is not in any of the dictForLength's"];
        }
        BYT *st=(BYT*)[self dictStartForLength:len];
        int at=(int)(((BYT*)addr)-st);
        UnpackedWord wd;
        unpackWord(&addr,&wd);
        [self _removeBytesForLength:len at:at numBytes:(int)(((BYT*)addr)-((BYT*)wd.addr))];
        return(YES);
    }

    - (bool)_addWordAtAddress:(unsigned short*)addr word:(UnpackedWord)word {
        if (addr==nil) return(NO);
        int len;
        for (len=0;len<NUMLENGTHS;len++) {
            if ((addr>=[self dictStartForLength:len])&&(addr<=[self dictEndForLength:len])) break;
        }
        if (len==NUMLENGTHS) {
            [NSException raise:@"Invalid operation" format:@"The address given is not in any of the dictForLength's"];
        }
        BYT *st=(BYT*)[self dictStartForLength:len];
        int at=(int)(((BYT*)addr)-st);
        
        unsigned short buf[35];
        int numBytes=sizeof(short)*makeUnpackedWordForFile(&word,buf);
        if (numBytes==0) return(NO);
        
        [self _addBytesForLength:len at:at numBytes:numBytes bytes:(void*)buf];
        return(YES);
    }

    - (bool)_moveWordFromAddress:(unsigned short*)fromAddr toAddr:(unsigned short*)toAddr newFreq:(float)freq {
        if ((fromAddr==nil)||(toAddr==nil)) return(NO);
        int len;
        for (len=0;len<NUMLENGTHS;len++) {
            if ((fromAddr>=[self dictStartForLength:len])&&(fromAddr<[self dictEndForLength:len])) break;
        }
        if (len==NUMLENGTHS) {
            [NSException raise:@"Invalid operation" format:@"The address given is not in any of the dictForLength's"];
        }
        if (!((toAddr>=[self dictStartForLength:len])&&(toAddr<=[self dictEndForLength:len]))) {
            [NSException raise:@"Invalid operation" format:@"The to address given is not in the same dictForLength as the from address"];
        }
        BYT *st=(BYT*)[self dictStartForLength:len];
        int from=(int)(((BYT*)fromAddr)-st);
        int to=(int)(((BYT*)toAddr)-st);
        
        UnpackedWord wd;
        unpackWord(&fromAddr,&wd);

        wd.freq=freq;
        
        unsigned short buf[35];
        int numBytes=sizeof(short)*makeUnpackedWordForFile(&wd,buf);
        if (numBytes==0) return(NO);

        int fromNumBytes=(int)(((BYT*)fromAddr)-(BYT*)wd.addr);
        
        if (numBytes==fromNumBytes) {		
            [self _moveBytesForLength:len from:from to:to numBytes:numBytes bytes:(void*)buf];
        }
        else if ((to<=from)||(to>=from+fromNumBytes)) {
            [self _addBytesForLength:len at:to numBytes:numBytes bytes:(void*)buf];
            [self _removeBytesForLength:len at:from numBytes:fromNumBytes];
        }
        else {
            [NSException raise:@"Invalid operation" format:@"move would insert word into itself"];
        }
        return(YES);
    }

    - (bool)removeWord:(NSString*)str {
        @synchronized (self) {
            if ([self _removeWordAtAddress:[self _findWord:str]]) {
                [self verifyOrAlert];
                changed=YES;return(YES);
            }
            else return(NO);
        }
    }

    - (bool)addWord:(NSString*)str freq:(float)freq freqIsMultiplier:(bool)freqIsMultiplier {
        @synchronized (self) {
            if (str.length>=MAXWORDLEN) return(NO);
            unsigned short *addr=[self _findWord:str],*addr2=addr;
            if (addr) {
                UnpackedWord wd;unpackWord(&addr2,&wd);
                if (freqIsMultiplier) freq*=wd.freq;
                if (wd.freq==freq) return(YES);
                unsigned short *toAddr=[self _findFreq:freq wordLengthIndex:wordLenIndex(str)];
                if ([self _moveWordFromAddress:addr toAddr:toAddr newFreq:freq]) {
                    [self verifyOrAlert];
                    changed=YES;return(YES);
                }
                else return(NO);

            }
            else if (freqIsMultiplier) return(NO);
            else {
                unsigned short *toAddr=[self _findFreq:freq wordLengthIndex:wordLenIndex(str)];
                UnpackedWord wd;
                memset(&wd,0,sizeof(wd));
                strcpy(wd.word,[str UTF8String]);
                wd.freq=freq;
                if ([self _addWordAtAddress:toAddr word:wd]) {
                    [self verifyOrAlert];
                    changed=YES;return(YES);
                }
                else return(NO);
            }
        }
    }

    - (bool)setWordFreq:(NSString*)str toFreq:(float)freq freqIsMultiplier:(bool)freqIsMultiplier {
        if ([self addWord:str freq:freq freqIsMultiplier:freqIsMultiplier]) {changed=YES;return(YES);}
        else return(NO);
    }


    - (UnpackedWord)findWord:(NSString*)str {
        UnpackedWord ret;memset(&ret,0,sizeof(ret));
        @synchronized (self) {
            unsigned short *ps=[self _findWord:str];
            if (ps) unpackWord(&ps, &ret);
            return(ret);
        }
    }


















    /*interfaces
    #define MAXPOTS (1000)
    static unsigned short *pot_best[MAXPOTS];
    static float pot_bestp[MAXPOTS];
    static int pot_maxResults,pot_numBest;


    //#define VERIFYDICT

    static inline int addToBest(unsigned short *addr,float p) {
        int i;
        

        if (pot_numBest==pot_maxResults) {
            if (p<=pot_bestp[0]) return(-1);
            
    #define IPVAR p
    #define IPARR(__i) pot_bestp[__i]
            INSERTPOS(pot_numBest,i);
    #undef IPVAR
    #undef IPARR

            if (--i) {
                memmove(pot_best,pot_best+1,sizeof(*pot_best)*i);
                memmove(pot_bestp,pot_bestp+1,sizeof(*pot_bestp)*i);
            }
            
        }
        else {
            
    #define IPVAR p
    #define IPARR(__i) pot_bestp[__i]
            INSERTPOS(pot_numBest,i);
    #undef IPVAR
    #undef IPARR
            
            if (i<pot_numBest) {
                memmove(pot_best+(i+1),pot_best+i,sizeof(pot_best[0])*(pot_numBest-i));
                memmove(pot_bestp+(i+1),pot_bestp+i,sizeof(pot_bestp[0])*(pot_numBest-i));
            }
            
            pot_numBest++;
        }
        
        pot_best[i]=addr;
        pot_bestp[i]=p;
        
    #ifdef VERIFYDICT
        for (int j=1;j<pot_numBest;j++) if (pot_bestp[j-1]>pot_bestp[j]) {
            [NSException raise:@"ver err" format:@"out of order"];
        }
    #endif
        
        return(i);
    }









    double rangeMul(double v,double mid,double range) {
        if (range<0.0000001) return(1);
        else {
            double ret=1-fabs(v-mid)/range;
            return(ret<0?0:(ret<0.2?ret/0.2:1));
        }
    }




    double maxNumLetters(double numLetters,double maxMulLen) {
        return(numLetters*maxMulLen+(maxMulLen-1)*3);
    }
    */
    
    - (double) adjustedMissingMulForNumTaps:(int)numTaps {
        double oneLetterWordPrecisionPower=2;
        int maxPresisionedNumTaps=3;
        if (numTaps<=maxPresisionedNumTaps) {
            double power=1+(oneLetterWordPrecisionPower-1)*(maxPresisionedNumTaps+1-numTaps)/maxPresisionedNumTaps;
            return(pow(missingMul,power));
        }
        else return(missingMul);
    }
        


    - (void)getBest:(float**)letterMuls numLetters:(int)numTaps length:(double)length lengthRange:(double)lengthRange maxResults:(int)maxResults {
        
        double adjMissingMul=[self adjustedMissingMulForNumTaps:numTaps];
        
        pot_numBest=0;
        pot_maxResults=maxResults;
        
        int potentialsToGo=maxPotentials;
        
        int lenFrom=numTaps;
        if ((lengthRange>0)&&(lenFrom<length-lengthRange)) lenFrom=(int)ceil(length-lengthRange);
        if (lenFrom<1) lenFrom=1;
        
        int lenTo=maxNumLetters(numTaps,maxWordLengthMul);
        if ((lengthRange>0)&&(lenTo>length+lengthRange)) lenTo=(int)floor(length+lengthRange);
        if (lenTo>NUMLENGTHS) lenTo=NUMLENGTHS;
        
        lenTo--;lenFrom--;
        
        if (lenTo<lenFrom) return;

        
        unsigned short *nxtWd[NUMLENGTHS],*endWd[NUMLENGTHS];
        unsigned char ord[NUMLENGTHS];
        unsigned char ind;
        
        float lenBaseMul[NUMLENGTHS],lenMul[NUMLENGTHS],lenFreq[NUMLENGTHS],f;

        int nlen=0,len;
        for (len=0;len<NUMLENGTHS;len++) {
            lenBaseMul[len]=((len>=lenFrom)&&(len<=lenTo)?rangeMul(len,length,lengthRange):0);
            for (int i=numTaps;i<=len;i++) lenBaseMul[len]*=adjMissingMul;
            if (lenBaseMul[len]>0) {
                nxtWd[len]=[self dictStartForLength:len];
                endWd[len]=[self dictEndForLength:len];
                wordAddressFreq(nxtWd[len],lenFreq[len]);
                lenMul[len]=lenFreq[len]*lenBaseMul[len];
                
                f=lenMul[len];
    #define IPVAR f
    #define IPARR(__i) lenMul[ord[__i]]
                INSERTPOS(nlen,ind);
    #undef IPVAR
    #undef IPARR
                if (ind<nlen) memmove(ord+(ind+1),ord+ind,sizeof(char)*(nlen-ind));
                ord[ind]=len;
                nlen++;
            }
            else lenMul[len]=-1;
        }

        float worstBestProb=0;
        
    //	NSLog(@"\n\nFind %d taps\n",numTaps);
        while (nlen&&potentialsToGo) {
    #ifdef VERIFYDICT
            for (int j=1;j<nlen;j++) {
                if (!nxtWd[ord[j]]) {
                    [NSException raise:@"ver err" format:@"nxtWd is nil"];
                }
                if (lenMul[ord[j-1]]>lenMul[ord[j]]) {
                    [NSException raise:@"ver err" format:@"out of order (2)"];
                }
            }
    #endif
            len=ord[nlen-1];

            if (lenFreq[len]<=fmin(worstBestProb,minFreq)) break;
                
    //		unsigned short *ps=nxtWd[len];
    //		UnpackedWord upwd;unpackWord(&ps,&upwd);
    //		if (!strcmp(upwd.word,"text")) {
    //			upwd.freq+=0;
    //		}
    //		NSLog(@"[%d] %s  freq:%f  ",potentialsToGo, upwd.word,upwd.freq);
            if ((f=wordMatchProbability(nxtWd[len],numTaps,letterMuls,
                                        lenMul[len],worstBestProb))>0) {
                potentialsToGo--;

                if (f>0) {
                    if (f>worstBestProb) {
                        addToBest(nxtWd[len],f);
                        if (pot_numBest==pot_maxResults) worstBestProb=pot_bestp[0];
                    }
                }
            }
            
            if ((nxtWd[len]=nextWordAddress(nxtWd[len]))>=endWd[len]) {
                nlen--;
            }
            else {
                wordAddressFreq(nxtWd[len],f);
                lenFreq[len]=f;
                f*=lenBaseMul[len];
                    
    #define IPVAR f
    #define IPARR(__i) lenMul[ord[__i]]
                INSERTPOS(nlen,ind);
    #undef IPVAR
    #undef IPARR
                lenMul[len]=f;
                    
                if (ind<nlen-1) {
                    memmove(ord+(ind+1),ord+ind,sizeof(char)*(nlen-1-ind));
                    ord[ind]=len;
                }
            }
        }
    }








        



    -(NSArray*)getBestWordsWithLetters:(float**)letterMuls numLetters:(int)numTaps length:(double)length lengthRange:(double)lengthRange maxResults:(int)maxResults {
        @synchronized (self) {
            double oneLetterWordPrecisionPower=2;
            int maxPresisionedNumTaps=2;
            if (numTaps<=maxPresisionedNumTaps) {
                double power=1+(oneLetterWordPrecisionPower-1)*(maxPresisionedNumTaps+1-numTaps)/maxPresisionedNumTaps;
                for (int nt=0;nt<numTaps;nt++) {
                    for (int l=0;l<NUMLETTERS;l++) letterMuls[l][nt]=pow(letterMuls[l][nt],power);
                }
            }
            [self getBest:letterMuls numLetters:numTaps
                   length:length lengthRange:lengthRange
               maxResults:maxResults];

            // now a familiar type array to return
            // it has at most maxResults words as NSStrings, sorted by how close they are to the criteria, and these are the closest such words in the dictionary
            NSMutableArray *ret=[NSMutableArray arrayWithCapacity:pot_numBest];
            for (int i=pot_numBest-1;i>=0;i--) {
                unsigned short *ps=pot_best[i];
                UnpackedWord wd;
                unpackWord(&ps,&wd);
                [ret addObject:[[DictionaryWord alloc] initWithUnpackedWord:wd calculatedProb:pot_bestp[i]]];
            }
            
            return(ret);
        }
    }










type WordProbTrie "typedef:struct {BYT letter;int wi;int childIndexes[NUMLETTERS];ULL subtreeHash;int offset;bool overridden;}"


Dictionary

    int _numWords=0
    int numWords={
        if (!_numWords) {
            for (int len=0;len<NUMLENGTHS;len++) {
                UnpackedWord wd;
                unsigned short *ps=[self dictStartForLength:len],*eps=[self dictEndForLength:len];
                while (ps<eps) {
                    unpackWord(&ps,&wd);
                    _numWords++;
                }
            }
        }
        return(_numWords);
    }


    NSMutableData *wordAddrData=nil
    WRD **wordAddrs={
        if (!v_wordAddrData) {
            self.wordAddrData=[NSMutableData dataWithLength:self.numWords*sizeof(unsigned short*)];
            unsigned short **wordAddrs=(unsigned short**)v_wordAddrData.mutableBytes;

            int wi=0;
            WRD *pss[NUMLENGTHS],*epss[NUMLENGTHS];
            for (int len=0;len<NUMLENGTHS;len++) {
                pss[len]=[self dictStartForLength:len];
                epss[len]=[self dictEndForLength:len];
            }
            
            while (wi<self.numWords) {
                int bestLen=-1;
                WRD *bestAddr=nil,*bestNextAddr=nil;
                double bestFreq=0;
                
                for (int len=0;len<NUMLENGTHS;len++) if (pss[len]<epss[len]) {
                    UnpackedWord wd;
                    WRD *addr=pss[len],*ps=addr;
                    unpackWord(&ps,&wd);
                    if ((!bestAddr)||(wd.freq>bestFreq)) {
                        bestAddr=addr;
                        bestNextAddr=ps;
                        bestFreq=wd.freq;
                        bestLen=len;
                    }
                }
                wordAddrs[wi++]=bestAddr;
                pss[bestLen]=bestNextAddr;                
            }
        }
        return((unsigned short **)v_wordAddrData.mutableBytes);
    }



    int _numWordsWithDistinctLetters=0
    int numWordsWithDistinctLetters={
        if (!_numWordsWithDistinctLetters) {
            ContextIndex ci={0};
            QuickHashTable<bool> ht(ci,NO);
            
            char word[128];
            unsigned short **wps=self.wordAddrs;
            for (int wi=0;wi<self.numWords;wi++) {
                UnpackedWord wd;
                unsigned short *ps=wps[wi];
                unpackWord(&ps,&wd);
                for (int li=0;li<wd.numLetters;li++) {
                    word[li]=wd.letters[li]+'a';
                }
                word[wd.numLetters]=0;
                ULL hash=makeStringHashCode(word);
                if (!ht[hash]) {
                    ht.add(hash,YES);
                    _numWordsWithDistinctLetters++;
                }
                
            }
        }
        return(_numWordsWithDistinctLetters);
    }


    NSMutableData *wordAddrWithDistinctLettersData=nil
    WRD **wordAddrsWithDistinctLetters={
        if (!v_wordAddrWithDistinctLettersData) {
            self.wordAddrWithDistinctLettersData=[NSMutableData dataWithLength:self.numWordsWithDistinctLetters*sizeof(unsigned short*)];
            unsigned short **wordAddrs=(unsigned short**)v_wordAddrWithDistinctLettersData.mutableBytes;

            ContextIndex ci={0};
            QuickHashTable<bool> ht(ci,NO);
            
            char word[128];
            unsigned short **wps=self.wordAddrs;
            for (int wi=0,towi=0;wi<self.numWords;wi++) {
                UnpackedWord wd;
                unsigned short *ps=wps[wi];
                unpackWord(&ps,&wd);
                for (int li=0;li<wd.numLetters;li++) {
                    word[li]=wd.letters[li]+'a';
                }
                word[wd.numLetters]=0;
                ULL hash=makeStringHashCode(word);
                if (!ht[hash]) {
                    ht.add(hash,YES);
                    wordAddrs[towi]=wps[wi];
                    towi++;
                }                
            }
        }
        return((unsigned short**)v_wordAddrWithDistinctLettersData.mutableBytes);
    }


    -(NSData*)compressWordProbTrie:(NSMutableData*)trie {
        WordProbTrie *wd=(WordProbTrie*)trie.mutableBytes;
        for (int i=0;i<trie.length/sizeof(WordProbTrie);i++) {
            wd[i].offset=-1;
            wd[i].overridden=NO;
        }
        NSMutableData *d=[NSMutableData dataWithLength:trie.length];
        BYT *b=(BYT*)d.mutableBytes;
        int bi=0;
        [self addWPT:wd windex:0 toBytes:b index:&bi];
        d.length=bi;
        return(d);
    }

    -(void)addWPT:(WordProbTrie*)awd windex:(int)windex toBytes:(BYT*)b index:(int*)pbi {
        WordProbTrie *wd=awd+windex;
        int bi=*pbi;
        if (wd->offset==-1) {
            wd->offset=bi;
            bool hasch=NO;
            for (int l=0;l<NUMLETTERS;l++) if (wd->childIndexes[l]) {hasch=YES;break;}
            BYT lb=0x80|(hasch?0x40:0)|(BYT)(wd->letter&0x1f);
            b[(*pbi)++]=lb;
            b[(*pbi)++]=(BYT)((wd->wi>>16)&0xff);
            b[(*pbi)++]=(BYT)((wd->wi>>8)&0xff);
            b[(*pbi)++]=(BYT)(wd->wi&0xff);
            for (int l=0;l<NUMLETTERS;l++) if (wd->childIndexes[l]) {
                [self addWPT:awd windex:wd->childIndexes[l] toBytes:b index:pbi];
            }
            if (hasch) {
                b[(*pbi)++]=0x80|0x20;
            }
        }
        else {
            b[(*pbi)++]=(BYT)((wd->offset>>16)&0x7f);
            b[(*pbi)++]=(BYT)((wd->offset>>8)&0xff);
            b[(*pbi)++]=(BYT)(wd->offset&0xff);
        }
    }
    int tnumWords=0

    -(NSMutableData*)wordProbTrieForNumLetters:(int)maxNumLetters {

        tnumWords=0;
        for (int len=0;len<NUMLENGTHS;len++) {
            UnpackedWord wd;
            unsigned short *ps=[self dictStartForLength:len],*eps=[self dictEndForLength:len];
            while (ps<eps) {
                unpackWord(&ps,&wd);
                tnumWords++;
            }
        }

        NSMutableData *addrd=[NSMutableData dataWithLength:tnumWords*sizeof(unsigned short*)];
        unsigned short **wordAddrs=(unsigned short **)addrd.mutableBytes;

        int wi=0;
        for (int len=0;len<NUMLENGTHS;len++) {
            UnpackedWord wd;
            unsigned short *ps=[self dictStartForLength:len],*eps=[self dictEndForLength:len];
            while (ps<eps) {
                wordAddrs[wi]=ps;
                unpackWord(&ps,&wd);
                wi++;
            }
        }

        NSMutableData *trie=[NSMutableData dataWithLength:1<<20];
        
        
        NSMutableIndexSet *wis=[NSMutableIndexSet indexSetWithIndexesInRange:NSMakeRange(0,tnumWords)];
        NSMutableData *d=[NSMutableData dataWithLength:tnumWords];
        BYT *lis=(BYT*)d.mutableBytes;
        memset(lis,0,tnumWords);
        
        NSMutableArray *wiStack=[NSMutableArray array];
        NSMutableArray *liStack=[NSMutableArray array];
        NSMutableDictionary *seen=[NSMutableDictionary dictionary];
        NSMutableDictionary *seenSubtree=[NSMutableDictionary dictionary];
        
        char letters[1000];
        
        int tot=0,triei=0;
        
        [self trieCountFromNumLetters:0 maxNumLetters:maxNumLetters letters:letters withWordIndexes:wis wordLetterIndexes:lis wiStack:wiStack liStack:liStack wordAddrs:wordAddrs seen:seen seenSubtree:seenSubtree tot:&tot trie:trie triei:&triei];
    
        trie.length=sizeof(WordProbTrie)*triei;
        return(trie);
    }

    -(int)trieCountFromNumLetters:(int)numLetters maxNumLetters:(int)maxNumLetters letters:(char*)letters withWordIndexes:(NSIndexSet*)wis wordLetterIndexes:(BYT*)lis wiStack:(NSMutableArray*)wiStack liStack:(NSMutableArray*)liStack wordAddrs:(unsigned short**)wordAddrs seen:(NSMutableDictionary*)seen seenSubtree:(NSMutableDictionary*)seenSubtree tot:(int*)ptot trie:(NSMutableData*)trie triei:(int*)triei {
        
        if (trie.length<=((*triei)+1)*sizeof(WordProbTrie)) {
            trie.length=2*trie.length;
        }
        int myTriei=(*triei)++;
        WordProbTrie *wp=((WordProbTrie*)trie.mutableBytes)+myTriei;
        
        wp->letter=(BYT)(numLetters?letters[numLetters-1]-'a':0xff);
        wp->wi=(int)wis.firstIndex;
        memset(wp->childIndexes,0,NUMLETTERS*sizeof(wp->childIndexes[0]));
        wp->subtreeHash=obfuscateULL((1LL<<wp->letter)*wp->wi);
        
        int ret=1;
        (*ptot)++;
        //int wi=0;
        
        if (wiStack.count<=numLetters) [wiStack addObject:[NSMutableIndexSet indexSet]];
        if (liStack.count<=numLetters) [liStack addObject:[NSMutableData dataWithLength:tnumWords]];
        NSMutableIndexSet *chwis=[wiStack objectAtIndex:numLetters];
        BYT *chlis=(BYT*)((NSMutableData*)[liStack objectAtIndex:numLetters]).mutableBytes;
        
        UnpackedWord wd;
        
        if (numLetters<maxNumLetters) for (int l=0;l<NUMLETTERS;l++) {
            [chwis removeAllIndexes];
            ULL hash=0;
            for (Unsigned wi=wis.firstIndex;wi!=NSNotFound;wi=[wis indexGreaterThanIndex:wi]) {
                unsigned short *ps=wordAddrs[wi];
                unpackWordLetters(&ps,&wd);
                if (lis[wi]<wd.numLetters) {
                    for (BYT li=lis[wi];li<wd.numLetters;li++) if (wd.letters[li]==l) {
                        [chwis addIndex:wi];
                        chlis[wi]=li+1;
                        hash+=obfuscateULL((((ULL)wi)<<10)|li);
                        break;
                    }
                }
            }
            if (chwis.count) {
                NSNumber *n=[[NSNumber alloc] initWithUnsignedLongLong:hash];
                letters[numLetters]=char5[l+6];
                NSNumber *ti=[seen objectForKey:n];
                if (ti) {
                    if (numLetters<2) {
                        for (int i=0;i<=numLetters;i++) printf(" %c",letters[i]);printf(" ...\n");
                    }
                    wp=((WordProbTrie*)trie.mutableBytes)+myTriei;
                    wp->childIndexes[l]=ti.intValue;
                    WordProbTrie *chwp=((WordProbTrie*)trie.mutableBytes)+ti.intValue;
                    wp->subtreeHash+=obfuscateULL((1LL<<l)*chwp->subtreeHash);
                }
                else {
                    int chtriei=*triei,chtot=*ptot;
                    wp=((WordProbTrie*)trie.mutableBytes)+myTriei;
                    wp->childIndexes[l]=chtriei;
                    WordProbTrie *chwp=((WordProbTrie*)trie.mutableBytes)+chtriei;
                    wp->subtreeHash+=obfuscateULL((1LL<<l)*chwp->subtreeHash);
                    
                    [seen setObject:@(*triei) forKey:n];
                    if (numLetters<2) {
                        for (int i=0;i<=numLetters;i++) printf(" %c",letters[i]);printf(" : tot:%d=%lu  subtree:%d=%lu\n",*ptot,seen.count,*triei,seenSubtree.count);
                    }
                    ret+=[self trieCountFromNumLetters:numLetters+1 maxNumLetters:maxNumLetters letters:letters withWordIndexes:chwis wordLetterIndexes:chlis wiStack:wiStack liStack:liStack wordAddrs:wordAddrs seen:seen seenSubtree:seenSubtree tot:ptot trie:trie triei:triei];
                    
                    chwp=((WordProbTrie*)trie.mutableBytes)+chtriei;

                    NSNumber *nst=[[NSNumber alloc] initWithUnsignedLongLong:chwp->subtreeHash];
                    NSNumber *tist=[seenSubtree objectForKey:nst];
                    if (tist) {
                        wp=((WordProbTrie*)trie.mutableBytes)+myTriei;
                        wp->childIndexes[l]=tist.intValue;
                        *triei=chtriei;
                        *ptot=chtot;
                    }
                    else [seenSubtree setObject:@(chtriei) forKey:nst];
                }
            }
        }
        return(ret);
    }
        
        
        











Globals
    -top
        #include <iostream>
        #define MAINCPPFILE
        #define CPPTYPE(...) __VA_ARGS__
        #include "../BasicClassesCPP/Headers.h"

type PattStr "typedef:struct {char pattern[28];}"
type ProMPWordsContext "typedef:struct {ManagedArray<StorableArray<PattStr> > *todo;Array<int> *todois;long todoCount;QuickHashTable<char> *seenMaxHT;QuickHashTable<bool> *seenWisHT;}"
sys BCString
sys BCArray_BigUInt
sys BCArray_int
sys BCArray_bool

type Wd "typedef:struct {char word[MAXWORDLEN];float freq;ULL pattMask;}"

type QHT_bool "typedef:QuickHashTable<bool>"
type constchar "typedef:const char"

ProMPWords
    ProMPWordsContext ctxt=nil


    -(init)init {}
    -(init) {
        {
            ContextIndex ci={0};
            ctxt.seenMaxHT=new QuickHashTable<char>(ci,0);
            ctxt.seenWisHT=new QuickHashTable<bool>(ci,NO);
            //ctxt.strings=new ClassStore<String>(MakeCC("ST"));
            ctxt.todoCount=0;
            ctxt.todo=new ManagedArray<StorableArray<PattStr> >(MakeCC("ms"),MakeCC("ss"));
            ctxt.todois=new Array<int>();
        }
    }

    -(void)printCtxt {
        printf("seenMaxs:%ld -- seenWiss:%ld -- todo:%ld:",ctxt.seenMaxHT->numCellsFilled(),ctxt.seenWisHT->numCellsFilled(),ctxt.todoCount);
        for (int i=0;i<ctxt.todo->num();i++) printf("[%d]%d<%ld  ",i,ctxt.todois->a[i],ctxt.todo->get(i).num());
        printf("\n");
    }

    -(void)dealloc {
        delete ctxt.seenMaxHT;
        delete ctxt.seenWisHT;
        delete ctxt.todo;
        delete ctxt.todois;
    }






    -(ULL)strHash_pc:(const char*)pc {
        return(makeStringHashCode(pc));
    }

    -(bool)haveSeenWisHash_addIfNot:(ULL)hash {
        if ((*ctxt.seenWisHT)[hash]) return(YES);
        ctxt.seenWisHT->add(hash,YES);
        return(NO);
    }

    -(bool)haveSeenMax_addIfNot:(const char*)max explore:(bool)explore wisCount:(Unsigned)wisCount {
        ULL hash=[self strHash_pc:max];
        char c=(*ctxt.seenMaxHT)[hash];
        if ((c==YES)||((c=='?')&&!explore)) return(YES);
        
        if (!c) {
            [self prntPattern:max];
        }
        
        if (!explore) {
            ctxt.seenMaxHT->add(hash,'?');
            return(NO);
        }

        if ((wisCount!=NSNotFound)&&([self wordIndexesMatchingPattern:max].count!=wisCount)) {
            ctxt.seenMaxHT->add(hash,'?');
            return(NO);
        }
        
        
        if (c) ctxt.seenMaxHT->changeDataForLastFind(YES);
        else ctxt.seenMaxHT->add(hash,YES);
        
        PattStr s;strcpy(s.pattern,max);
        Array<PattStr> &pa=ctxt.todo->get(strlen(s.pattern));
        int &N=ctxt.todois->a[strlen(s.pattern)];
        while (pa.upperBound()<N) pa.setUpperBound(pa.num()*3/2);
        pa A[N++]=s;
        ctxt.todoCount++;
        return(NO);
    }


    -(PattStr)nextMax {
        PattStr ret={""};
        int length=-1;
        IterateArray(int,N,*ctxt.todois,  if (N) length=(int)NIndex;);
        if (length==-1) return(ret);

        Array<PattStr> &pa=ctxt.todo->get(length);
        int &N=ctxt.todois->a[length];
        ctxt.todoCount--;
        return(pa A[--N]);
    }



    int numWords=20

    NSMutableData *_wordsd=nil
    Wd *_words=nil;
    Wd *words={
        if (!_words) {
            int maxLen=0;
            ContextIndex ci={0};
            QuickHashTable<bool> ht(ci,NO);
            
            Dictionary *dict=[Dictionary getDefault];
            self._wordsd=[NSMutableData dataWithLength:sizeof(Wd)*self.numWords];
            _words=(Wd*)v__wordsd.mutableBytes;
            memset(_words,0,sizeof(Wd)*self.numWords);
            unsigned short **wps=dict.wordAddrsWithDistinctLetters;
            for (int wi=0,towi=0;towi<self.numWords;wi++) {
                UnpackedWord wd;
                unsigned short *ps=wps[wi];
                unpackWord(&ps,&wd);
                for (int li=0;li<wd.numLetters;li++) {
                    _words[towi].word[li]=wd.letters[li]+'a';
                }
                _words[towi].word[wd.numLetters]=0;
                ULL hash=makeStringHashCode(_words[towi].word);
                if (!ht[hash]) {
                    ht.add(hash,YES);
                    _words[towi].freq=wd.freq;
                    _words[towi].pattMask=0;
                    printf("word %d: %s\n",wi,_words[towi].word);
                    maxLen=MAX(maxLen,(int)strlen(_words[towi].word));
                    towi++;
                }
                
            }
            oprnt("Max word len : %d\n",maxLen);
        }
        return(_words);
    }
    


    NSMutableArray incIndsStack=[NSMutableArray array] (readonly,ivar=incIndsStack,dealloc)
    -(NSMutableArray*)incIndsArrayForDepth:(int)depth {
        NSMutableArray *ret;
        while (incIndsStack.count<=depth) [incIndsStack addObject:[NSMutableArray array]];
        ret=[incIndsStack objectAtIndex:depth];
        [ret removeAllObjects];
        return(ret);
    }

    NSMutableArray indsStack=[NSMutableArray array] (readonly,ivar=indsStack,dealloc)
    -(NSMutableIndexSet*)indsIndexSetForDepth:(int)depth {
        NSMutableIndexSet *ret;
        while (indsStack.count<=depth) [indsStack addObject:[NSMutableIndexSet indexSet]];
        ret=[indsStack objectAtIndex:depth];
        [ret removeAllIndexes];
        return(ret);
    }








    NSMutableArray maxPattIndsStack=[NSMutableArray array] (readonly,ivar=maxPattIndsStack,dealloc)

    -(int*)getMaxPattIndsForDepth:(int)d num:(int)n {
        while (maxPattIndsStack.count<=d) [maxPattIndsStack addObject:[NSMutableData dataWithLength:n*sizeof(int)]];
        NSMutableData *retd=[maxPattIndsStack objectAtIndex:d];
        if (retd.length<n*sizeof(int)) {
            retd.length=n*sizeof(int);
        }
        return((int*)retd.mutableBytes);
    }








        
    -(void)oprntWisWords:(NSIndexSet*)wis {
        Wd *wds=self.words;
        oprnt("Wordsx%d:",wis.count);
        for (Unsigned wii=0,wi=wis.firstIndex;wi!=NSNotFound;wi=[wis indexGreaterThanIndex:wi],wii++) {
            oprnt(" %s",wds[wi].word);
        }
        oprnt("\n");
    }






    WPatternArray *addMaxWPA=nil (readonly)
    -(init) {
        addMaxWPA=NEW(WPatternArray);
        addMaxWPA->setUpperBound(99);
    }
    -(void)dealloc {
        DELETE(WPatternArray,addMaxWPA);
    }

    

    -(int)addMaxPatternsForWordsAtIndexes:(NSIndexSet*)wis {
        WPatternArray &maxs=*addMaxWPA;
        int N=0;
        
        int *inds=[self getMaxPattIndsForDepth:0 num:(int)wis.count];
        for (int wii=0;wii<wis.count;wii++) inds[wii]=-1;

        //[self oprntWisWords:wis];
        bool deb=NO;//(wis.count==4);
        
        Wd maxWd;
        [self addMaxPatternsForWordsAtIndexes:wis fromInds:inds indDepth:1 maxWd:&maxWd deb:deb to:&maxs toi:&N];
        
        maxs.setUpperBound(N-1);
        int Nbase=N;
        [self addMidPatternsTo:&maxs];

        IterateArray(WPattern,p,maxs,
            if (deb) oprnt("%s\n",p.pattern);
            [self haveSeenMax_addIfNot:p.pattern explore:pIndex<Nbase wisCount:wis.count];
        );
        return((int)maxs.num());
    }
//1000->8623 10000->191404own



    -(int)addMaxPatternsForWordsAtIndexes:(NSIndexSet*)wis fromInds:(int*)parInds indDepth:(int)indDepth maxWd:(Wd*)maxWd deb:(bool)deb to:(WPatternArray*)to toi:(int*)pN {
        int ret=0;
        
        bool countedCommonLetter[NUMLETTERS];
        int commonLetterCount[NUMLETTERS];
        Wd *wds=self.words;
        memset(commonLetterCount,0,sizeof(int)*NUMLETTERS);
        int wii;Unsigned wi;
        for (wii=0,wi=wis.firstIndex;wi!=NSNotFound;wi=[wis indexGreaterThanIndex:wi],wii++) {
            memset(countedCommonLetter,0,sizeof(bool)*NUMLETTERS);
            for (char *pc=wds[wi].word+(parInds[wii]+1);*pc;pc++) if (!countedCommonLetter[(*pc)-'a']) {
                countedCommonLetter[(*pc)-'a']=YES;
                commonLetterCount[(*pc)-'a']++;
            }
        }
        for (int li=0;li<NUMLETTERS;li++) if (commonLetterCount[li]==wis.count) {
            bool nonOverrideCommonLetters[NUMLETTERS];
            memset(nonOverrideCommonLetters,0,sizeof(bool)*NUMLETTERS);
            for (wii=0,wi=wis.firstIndex;wi!=NSNotFound;wi=[wis indexGreaterThanIndex:wi],wii++) {
                memset(countedCommonLetter,0,sizeof(bool)*NUMLETTERS);
                for (char *pc=wds[wi].word+(parInds[wii]+1);(*pc)!='a'+li;pc++) {
                    countedCommonLetter[(*pc)-'a']=YES;
                }
                for (int li2=0;li2<NUMLETTERS;li2++) if ((li!=li2)&&(commonLetterCount[li2]==wis.count)) {
                    if (!countedCommonLetter[li2]) nonOverrideCommonLetters[li2]=YES;
                }
            }
            for (int li2=0;li2<NUMLETTERS;li2++) if ((li!=li2)&&(commonLetterCount[li2]==wis.count)&&!nonOverrideCommonLetters[li2]) {
                commonLetterCount[li]=-1;
            }
        }
        int nl=0;
        for (int li=0;li<NUMLETTERS;li++) if (commonLetterCount[li]==wis.count) nl++;
        if (!nl) {
            maxWd->word[indDepth-1]=0;
            WPattern p;memset(&p,0,sizeof(p));
            strcpy(p.pattern,maxWd->word);
            while ((*pN)>=to->num()) to->setUpperBound(to->num()*2-1);
            (*to)A[(*pN)++]=p;
            ret++;
        }
        else for (int li=0;li<NUMLETTERS;li++) if (commonLetterCount[li]==wis.count) {
            int *inds=[self getMaxPattIndsForDepth:indDepth num:(int)wis.count];
        
            for (wii=0,wi=wis.firstIndex;wi!=NSNotFound;wi=[wis indexGreaterThanIndex:wi],wii++) {
                inds[wii]=parInds[wii]+1;
                for (char *pc=wds[wi].word+inds[wii];(*pc)!='a'+li;pc++,inds[wii]++);
            }
        
            maxWd->word[indDepth-1]=li+'a';
            ret+=[self addMaxPatternsForWordsAtIndexes:wis fromInds:inds indDepth:indDepth+1 maxWd:maxWd deb:deb to:to toi:pN];
        }
        return(ret);
    }








    
    -(Unsigned)incedWordIndexesForWordIndexes:(NSIndexSet*)wis withMaximal:(const char*)maxWd ret:(NSMutableArray*)ret {
        //fprintf(stderr,"i");

        Unsigned retN=0;
        
        int N=(int)strlen(maxWd);
        
        Wd *wds=self.words;
        int wii;Unsigned wi;

        if (N) {
            int *inds=[self getMaxPattIndsForDepth:0 num:(int)wis.count];
        
            for (wii=0,wi=wis.firstIndex;wi!=NSNotFound;wi=[wis indexGreaterThanIndex:wi],wii++) {
                inds[wii]=0;
                for (char *pc=wds[wi].word;*pc!=maxWd[0];pc++,inds[wii]++);
            }
            for (int i=1;i<N;i++) {
                int *inds2=[self getMaxPattIndsForDepth:i num:(int)wis.count];
                for (wii=0,wi=wis.firstIndex;wi!=NSNotFound;wi=[wis indexGreaterThanIndex:wi],wii++) {
                    inds2[wii]=inds[wii]+1;
                    for (char *pc=wds[wi].word+inds2[wii];*pc!=maxWd[i];pc++,inds2[wii]++);
                }
                inds=inds2;
            }
        
            inds=[self getMaxPattIndsForDepth:2*N-1 num:(int)wis.count];

            for (wii=0,wi=wis.firstIndex;wi!=NSNotFound;wi=[wis indexGreaterThanIndex:wi],wii++) {
                inds[wii]=((int)strlen(wds[wi].word))-1;
                for (char *pc=wds[wi].word+inds[wii];*pc!=maxWd[N-1];pc--,inds[wii]--);
            }
            for (int i=1;i<N;i++) {
                int *inds2=[self getMaxPattIndsForDepth:2*N-1-i num:(int)wis.count];
                for (wii=0,wi=wis.firstIndex;wi!=NSNotFound;wi=[wis indexGreaterThanIndex:wi],wii++) {
                    inds2[wii]=inds[wii]-1;
                    for (char *pc=wds[wi].word+inds2[wii];*pc!=maxWd[N-1-i];pc--,inds2[wii]--);
                }
                inds=inds2;
            }
        }

        
        for (int i=-1;i<N;i++) {
            bool canAdd[NUMLETTERS];
            memset(canAdd,0,NUMLETTERS*sizeof(bool));
            
            int *fromInds=(i==-1?nil:[self getMaxPattIndsForDepth:i num:(int)wis.count]);
            int *toInds=(i==N-1?nil:[self getMaxPattIndsForDepth:N+1+i num:(int)wis.count]);
            
            for (wii=0,wi=wis.firstIndex;wi!=NSNotFound;wi=[wis indexGreaterThanIndex:wi],wii++) {
                Wd *wd=wds+wi;
                int st=(fromInds?fromInds[wii]+1:0);
                int en=(toInds?toInds[wii]-1:(((int)strlen(wd->word))-1));
                for (int ci=st;ci<=en;ci++) canAdd[wd->word[ci]-'a']=YES;
            }
            
            for (int li=0;li<NUMLETTERS;li++) if (canAdd[li]) {
                ULL hash=0;int count=0;
                for (wii=0,wi=wis.firstIndex;wi!=NSNotFound;wi=[wis indexGreaterThanIndex:wi],wii++) {
                    int st=(fromInds?fromInds[wii]+1:0);
                    int en=(toInds?toInds[wii]-1:(((int)strlen(wds[wi].word))-1));
                    bool hasc=NO;
                    for (int ci=st;ci<=en;ci++) if (wds[wi].word[ci]-'a'==li) {hasc=YES;break;}
                    if (hasc) {
                        hash+=obfuscateULL(wi);
                        count++;
                    }
                }
                if (![self haveSeenWisHash_addIfNot:hash]) {
                    NSMutableIndexSet *is;
                    if (ret.count<=retN) {
                        is=[[NSMutableIndexSet alloc] init];
                        [ret addObject:is];
                    }
                    else {
                        is=(NSMutableIndexSet*)[ret objectAtIndex:retN];
                        [is removeAllIndexes];
                    }
                    
                    for (wii=0,wi=wis.firstIndex;wi!=NSNotFound;wi=[wis indexGreaterThanIndex:wi],wii++) {
                        int st=(fromInds?fromInds[wii]+1:0);
                        int en=(toInds?toInds[wii]-1:(((int)strlen(wds[wi].word))-1));
                        bool hasc=NO;
                        for (int ci=st;ci<=en;ci++) if (wds[wi].word[ci]-'a'==li) {hasc=YES;break;}
                        if (hasc) [is addIndex:wi];
                    }
                    retN++;
                }
            }
        }


        //{
        //    printf("%lu incs for indexes %s with max word %s:\n",ret.count,wis.description.UTF8String,maxWd);
        //    for (NSIndexSet *is in ret) {
        //        printf("    %s\n",is.description.UTF8String);
        //    }
        //    printf("\n");
        //}
        //fprintf(stderr,".");
        return(retN);
    }
    


    -(int)wordCountMatchingPattern:(const char*)wd {
        Wd *wds=self.words;
        int N=self.numWords,Nc=(int)strlen(wd),ret=0;
        for (int i=0;i<N;i++) {
            int j=0;
            for (char *pc=wds[i].word;(j<Nc)&&*pc;pc++) if (*pc==wd[j]) j++;
            if (j==Nc) ret++;
        }
        return(ret);
    }


    PattStr tmpWisPattern=nil
    -(init) {
        strcpy(tmpWisPattern.pattern,"xgdisugfyjlkfjslj");
    }
    NSMutableIndexSet tmpWis=[[NSMutableIndexSet alloc] init] (readonly,dealloc,ivar=tmpWis)

    -(NSIndexSet*)wordIndexesMatchingPattern:(const char*)wd {
        if (strcmp(tmpWisPattern.pattern,wd)) {
            strcpy(tmpWisPattern.pattern,wd);
            [self wordIndexesMatchingPattern:wd ret:tmpWis];
        }
        return(tmpWis);
    }

    -(NSIndexSet*)wordIndexesMatchingPattern:(const char*)wd ret:(NSMutableIndexSet*)ret {
        //fprintf(stderr,"w");

        [ret removeAllIndexes];
        Wd *wds=self.words;
        int N=self.numWords,Nc=(int)strlen(wd);
        for (int i=0;i<N;i++) {
            int j=0;
            for (char *pc=wds[i].word;(j<Nc)&&*pc;pc++) if (*pc==wd[j]) j++;
            if (j==Nc) [ret addIndex:i];
        }
        //fprintf(stderr,".");
        return(ret);
    }




    -(Unsigned)countMaximalSubpatterns {
        
        NSMutableArray *indsArray=[[NSMutableArray alloc] init];
        NSMutableIndexSet *wisIS=[[NSMutableIndexSet alloc] init];
        
        
        NSIndexSet *baseWis=[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0,self.numWords)];
        
        ctxt.todois->setUpperBound(1000000);
        IterateArray(int,N,*ctxt.todois,   N=0;);
        
        [self goFromWordSet:baseWis];

        int iti=0,priti=0;
        while (ctxt.todoCount) {
            PattStr p=[self nextMax];
            if (iti==priti) {
                priti+=iti/50+1;
                printf("\n[%d]\n",iti+1);
                [self printCtxt];
                oprintTypeAllocs();
                printf("%s\n",[MemMonitor memString].UTF8String);
                printf("tot:%lu done:%lu todo:%lu\n",ctxt.seenMaxHT->numCellsFilled(),prvRetCount,ctxt.todoCount);
                printf("\n");
                oprnt("%s\n",p.pattern);
            }
            
            [self goFromPattern:p.pattern tmpArray:indsArray];
            iti++;
        }
        fprintf(stderr,"\n%lu=%lu patterns total\n",ctxt.seenMaxHT->numCellsFilled(),prvRetCount);
        return(prvRetCount);
    }





    -(void)goFromWordSet:(NSIndexSet*)wis {
        [self addMaxPatternsForWordsAtIndexes:wis];
    }


    Unsigned prvRetCount=0;


    -(void)goFromPattern:(const char*)s tmpArray:(NSMutableArray*)indsArray {
        NSIndexSet *wis=[self wordIndexesMatchingPattern:s];
        Unsigned indN=[self incedWordIndexesForWordIndexes:wis withMaximal:s ret:indsArray];
        for (NSIndexSet *chwis in indsArray) {
            if (!(indN--)) break;
            [self goFromWordSet:chwis];
        }
    }






    -(void)prntPattern:(const char*)s {
        NSIndexSet *wis=[self wordIndexesMatchingPattern:s];
        BCArray_BigUInt *counts=[ssc countsByLengthForString:s];
        NSString *countStr=[ssc stringForCounts:counts ret:nil];
        prnt("[%lu]%s @ %lu x %lu -- %s\n",prvRetCount++,s,wis.firstIndex,wis.count,countStr.UTF8String);
    }


"<sys/time.h>"


type WPattern "typedef:struct {int index,fsti,num;char pattern[32];SchemaCount counts;}"
type WPatternArray "typedef:Array<WPattern>"
type IntArray "typedef:Array<int>"
type BYTArray "typedef:Array<unsigned char>"

ProMPWords
    -(WPattern)readNextPattern:(FILE*)fil {
        char buf[10000],word[128];
        WPattern ret={-1,-1,0,""},nret=ret;
        TA_init(ret.counts);
        TA_init(nret.counts);
        if (!fgets(buf,10000,fil)) return(nret);
        int i=0;
        char *pc=buf;
        //prnt("buf:%s\n",buf);
        if (sscanf(pc,"[%d]%n",&ret.index,&i)!=1) return(nret);
        pc+=i;
        char *pc2=ret.pattern;
        while ((*pc)&&(*pc!=' ')) (*(pc2++))=*(pc++);
        (*pc2)=0;
        
        if (sscanf(pc," @ %d x %d --%n",&ret.fsti,&ret.num,&i)!=2) return(nret);
        pc+=i;

        TA_setUpperBound(ret.counts,0);
        TA_A(ret.counts,0)=BigUIntFunctions::one();
        
        while (pc[0]==' ') {
            if (sscanf(pc," %s%n",word,&i)!=1) break;
            pc+=i;
            
            BigUInt bui=BigUIntFunctions::zero(),ten=BigUIntFunctions::fromLong(10);
            for (char *pc=word;*pc;pc++) {
                BigUInt dig=BigUIntFunctions::fromLong((*pc)-'0');
                BigUIntFunctions::multiplyInplace(bui,ten);
                BigUIntFunctions::addInplace(bui,dig);
            }
            TA_insert(ret.counts,TA_num(ret.counts),bui,1);
        }
        //NSString *str=[ssc stringForSCCounts:&ret.counts ret:nil];
        //printf("%s @ %d x %d -- %s\n",ret.pattern,ret.fsti,ret.num,str.UTF8String);
        return(ret);
    }

    NSString patternFilename=@"maxs.txt"


    WPatternArray *_patterns=nil
    -(void)dealloc {
        if (_patterns) {
            DELETE(WPatternArray,_patterns);
            _patterns=nil;
        }
    }
    WPatternArray *patterns={
        if (!_patterns) {
            FILE *fil=fopen(self.patternFilename.UTF8String,"rb");
            int N=0;
            for (WPattern p=[self readNextPattern:fil];p.index>=0;p=[self readNextPattern:fil]) {
                N++;
                clearSC(p.counts);
            }
            fseek(fil,0,SEEK_SET);
            _patterns=NEW(WPatternArray);
            _patterns->setUpperBound(N-1);
            int i=0;
            for (WPattern p=[self readNextPattern:fil];p.index>=0;p=[self readNextPattern:fil]) {
                (*_patterns)A[i++]=p;
            }
            fclose(fil);
        }
        oprnt("%d patterns\n",_patterns->num());
        return(_patterns);
    }



    -(int)addMidPatternsBetween:(const char*)a andPattern:(const char*)b buf:(char*)buf depth:(int)depth ht:(QuickHashTable<bool>*)ht to:(WPatternArray*)newpa toi:(int*)ptoi template:(WPattern*)templatep {
        int ret=0;
        while (*a) {
            const char *bb=b;
            while ((*bb)&&(*bb!=*a)) bb++;
            if (*bb) {
                buf[depth]=*a;
                ret+=[self addMidPatternsBetween:a+1 andPattern:bb+1 buf:buf depth:depth+1 ht:ht to:newpa toi:ptoi template:templatep];
            }
            a++;
        }
        if (depth&&!ret) {
            buf[depth]=0;
            ULL hash=makeStringHashCode(buf);
            if (!(*ht)[hash]) {
                ht->add(hash,YES);
                WPattern p=*templatep;
                memset(&p,0,sizeof(Pattern));
                strcpy(p.pattern,buf);
                //BCArray_BigUInt *counts=[ssc countsByLengthForString:buf];
                TA_init(p.counts);
                //TA_setUpperBound(p.counts,counts.num-1);
                //IterateArray(BigUInt,bui,*counts.cppArray,
                //    TA_A(p.counts,buiIndex)=bui;
                //    TA_init(bui);
                //);
                
                                                while (newpa->num()<=*ptoi) newpa->setUpperBound(newpa->upperBound()*2);
                newpa->a[(*ptoi)++]=p;
                ret++;
            }
        }
        return(ret);
    }

    QHT_bool *addMidHT=nil (readonly)
    WPatternArray *addMidWPA=nil (readonly)
    -(init) {
        {
            ContextIndex ci={0};
            addMidHT=NEWCONSb(QHT_bool,(ci,NO));
            addMidWPA=NEW(WPatternArray);
            addMidWPA->setUpperBound(99);
        }
    }
    -(void)dealloc {
        DELETE(QHT_bool,addMidHT);
        DELETE(WPatternArray,addMidWPA);
    }

    -(int)addMidPatternsTo:(WPatternArray*)ppa {
        QHT_bool &ht=*addMidHT;

        ht.clear();
        
        WPatternArray &pa=*ppa;
        IterateArray(WPattern,p,pa,
            ht.add(makeStringHashCode(p.pattern),YES);
        );

        char buf[128];
        WPattern templatep;
        
        WPatternArray &newpa=*addMidWPA;
        
        
        bool deb=NO;

        int ret=0;
        int z=0,n0=(int)pa.num(),n=n0,newn=0;
        if (deb) oprnt("\nMid patterns: %d ",n);
        while (n) {
            IterateArray(WPattern,p1,pa,
                if (z&&!p1Index) p1Index=z-1;
                else {
                    if (p1Index==n+z) break;
                    IterateArray(WPattern,p2,pa,
                        if ((p2Index==n0)||(p1Index==p2Index)) break;
                        templatep=((p1.fsti<p2.fsti)||((p1.fsti==p2.fsti)&&(strlen(p1.pattern)<strlen(p2.pattern)))?p1:p2);
                        TA_init(templatep.counts);
                        templatep.index=-1;
                        ret+=[self addMidPatternsBetween:p1.pattern andPattern:p2.pattern buf:buf depth:0 ht:&ht to:&newpa toi:&newn template:&templatep];
                    );
                }
            );
            if (!newn) break;
            z=(int)pa.num();n=newn;newn=0;
            if (deb) oprnt("+%d",n);
            pa.insert(z,newpa.a[0],n);
        }
        if (deb) oprnt("=%d\n",ret+n0);
        return(ret);
    }
        
        


    BCArray_int indByLength=[[BCArray_int alloc] init] (readonly,ivar=indByLength,dealloc)
    BCArray_int _sortedPatternIndexes_length=nil
    BCArray_int sortedPatternIndexes_length={
        if (!v__sortedPatternIndexes_length) {
            WPatternArray &pa=*self.patterns;
            Array<long> tmpa;
            BCArray_int *ret=[[BCArray_int alloc] init];
            Array<int> &reta=*ret.cppArray,froma;
            froma.setUpperBound(pa.upperBound());
            IterateArray(int,i,froma,   i=(int)iIndex;);
            prnt("sort<");
            linearSort(int,froma,reta,(int)strlen(pa.a[obj].pattern),tmpa);
            prnt(">sort");
            self._sortedPatternIndexes_length=ret;
            indByLength.upperBound=-1;
            int lenWas=-1;
            IterateArray(int,ind,*v__sortedPatternIndexes_length.cppArray,
                int len=(int)strlen(pa.a[ind].pattern);
                if (len>lenWas) {
                    while (indByLength.upperBound<len) [indByLength addValue:(int)indIndex];
                    lenWas=len;
                }
            );                    
        }
        return(v__sortedPatternIndexes_length);
    }


    BCArray_int _sortedPatternIndexes_freq=nil
    BCArray_int sortedPatternIndexes_freq={
        if (!v__sortedPatternIndexes_freq) {
            WPatternArray &pa=*self.patterns;
            Array<long> tmpa;
            BCArray_int *ret=[[BCArray_int alloc] init];
            Array<int> &reta=*ret.cppArray;
            reta.setUpperBound(pa.upperBound());
            IterateArray(int,i,reta,   i=(int)iIndex;);
            int tmpi;
            arrHeapSortb(int,reta,(pa.a[obja].fsti<pa.a[objb].fsti)||((pa.a[obja].fsti==pa.a[objb].fsti)&&(strlen(pa.a[obja].pattern)<strlen(pa.a[objb].pattern))),0,reta.upperBound(),tmpi);
            self._sortedPatternIndexes_freq=ret;
        }
        return(v__sortedPatternIndexes_freq);
    }


    BCArray_int wdis=[[BCArray_int alloc] init] (dealloc,readonly,ivar=wdis)

    float timenow={return(0);}

    -(void)subFromSups  {
        prnt("Get patterns and sort...");
        Array<int> &a=*self.sortedPatternIndexes_length.cppArray;
        WPatternArray &pa=*self.patterns;
        const char *sup,*sub;
        
        ManagedArray<StorableArray<int> > indsByContents(MakeCC("Ac"),MakeCC("ac"));
        indsByContents.get(28*26);
        IterateArray(WPattern,p,pa,
            for (int c=0;c<26;c++) {
                int qq=0;for (const char *pc=p.pattern;*pc;pc++) if (c+'a'==*pc) qq++;
                for (int q=0;q<qq;q++) {
                    Array<int> &a=indsByContents[c+26*q];
                    a+=(int)pIndex;
                }
            }
        );
        
        float st=self.timenow;
        
        int ibcis[26*28],nibciis=0,qc[26];
        int *ibcas[26*28];
        int ibcans[26*28];
        bool deb=NO;
        
        IterateArray(int,patterni,a,
            WPattern &pattern=pa.a[patterni];

            if (deb) {prnt("%s ",pattern.pattern);InterimSchemaCount::prntSC(pattern.counts);}

            if (!*pattern.pattern) {
                IterateArray(int,ind,a,
                    if (*pa.a[ind].pattern) {
                        if (![CountSubsequences subSCCounts:&pattern.counts from:&pa.a[ind].counts]) {
                            prnt("\n!!!no can do!!!  ");
                        }
                    }
                );
                continue;
            }
                
            
            int len=(int)strlen(pattern.pattern);
            if (len>=indByLength.upperBound) break;
            int fromi=indByLength.cppArray->a[len+1];
            
            if (!(patterniIndex%10)) prnt(".");
            if (!(patterniIndex%1000)) {
                float fin=self.timenow;
                prnt("\n%d/%d, len:%d fromi:%d ival-sec:%.2f\n",patterniIndex+1,a.num(),len,fromi,fin-st);
                st=fin;
            }

            memset(qc,0,sizeof(int)*26);
            for (const char *pc=pattern.pattern;*pc;pc++) qc[(*pc)-'a']++;
            nibciis=0;
            for (int c=0;c<26;c++) if (qc[c]) {
                int i=c+26*(qc[c]-1);
                ibcas[nibciis]=indsByContents.get(i).a;
                ibcans[nibciis]=(int)indsByContents.get(i).num();
                nibciis++;
            }
            
            memset(ibcis,0,sizeof(int)*nibciis);
            int newmax=0;
            while (newmax!=-1) {
                int max=ibcas[0][ibcis[0]];
                newmax=max;
                for (int i=1;i<nibciis;i++) max=MAX(max,ibcas[i][ibcis[i]]);
                
                for (int i=0;(newmax!=-1)&&(i<nibciis);i++) {
                    while (ibcas[i][ibcis[i]]<max) {
                        if ((++ibcis[i])>=ibcans[i]) {newmax=-1;break;}
                        newmax=MAX(newmax,ibcas[i][ibcis[i]]);
                    }
                }
                
                if (newmax==max) {
                    int ind=ibcas[0][ibcis[0]];
                    if (ind!=patterni) {
                        
                        sub=pattern.pattern;sup=pa.a[ind].pattern;
                        while (*sup) sub+=(int)((*sub)==(*(sup++)));

                        if (!*sub) {
                            if (deb) {prnt("       -from %s ",pa.a[ind].pattern);InterimSchemaCount::prntSC(pa.a[ind].counts);}

                            if (![CountSubsequences subSCCounts:&pattern.counts from:&pa.a[ind].counts]) {
                                prnt("\n!!!no can do!!!  ");
                            }

                        }
                    }
                    
                    for (int i=0;i<nibciis;i++) {
                        if ((++ibcis[i])>=ibcans[i]) {newmax=-1;break;}
                    }
                }
            }
                    

            //IterateArray(int,ind,a,
            //    if (indIndex<fromi) indIndex=fromi-1;
            //    else {
            //        sub=pattern.pattern;sup=pa.a[ind].pattern;
            //        while (*sup) sub+=(int)((*sub)==(*(sup++)));

            //        if (!*sub) {
            //            if (![CountSubsequences subSCCounts:&pattern.counts from:&pa.a[ind].counts]) {
            //                prnt("\n!!!no can do!!!  ");
            //            }
            //        }
            //    }
            //);
        );
        prnt("done.\n");
    }


    -(void)goOwnedPatternCounts {
        prnt("Get patterns and sort...");
        Array<int> &inds=*self.sortedPatternIndexes_length.cppArray;
        prnt(" .\n");
        WPatternArray &pa=*self.patterns;
        bool deb=NO;
        IterateArray(int,i,inds,
            if (!(iIndex%1000)) prnt("%d/%d\n",iIndex+1,inds.num());
            WPattern &pi=pa A[i];
            if (deb) {prnt("\n%s (%d) ",pi.pattern,pi.fsti);InterimSchemaCount::prntSC(pi.counts);}
            IterateArray(int,j,inds,
                if (jIndex==iIndex) break;
                WPattern &pj=pa A[j];
                if ([CountSubsequences string:pj.pattern isSubsequenceOf:pi.pattern]) {
                    if (deb) {prnt("       - %s ",pj.pattern);InterimSchemaCount::prntSC(pj.counts);}
                    if (![CountSubsequences subSCCounts:&pj.counts from:&pi.counts]) {
                        prnt("\n!!!no can do!!!  ");
                        break;
                    }
                }
            );
            if (deb) {prnt("   >>");InterimSchemaCount::prntSC(pi.counts);}
        );
    }
    
    
    -(void)writePatterns:(NSString*)fn evenMid:(bool)evenMid {
        FILE *fil=fopen(fn.UTF8String,"wb");
        NSMutableString *str=[NSMutableString string];
        Array<int> &inds=*self.sortedPatternIndexes_length.cppArray;
        WPatternArray &pa=*self.patterns;
        IterateArray(int,i,inds,
            WPattern &p=pa A[i];
            if ((!evenMid)&&(p.index<0)) continue;
            [ssc stringForSCCounts:&p.counts ret:str];
            fprintf(fil,"[%ld]%s @ %d x %d -- %s\n",iIndex,p.pattern,p.fsti,p.num,str.UTF8String);
        );
        fclose(fil);
    }


    -(void)goOwned {
        self.patternFilename=[NSString stringWithFormat:@"maxs%d.txt",self.numWords];
        //[self addMidPatterns];
        [self subFromSups];
        //[self goOwnedPatternCounts];
        [self writePatterns:[NSString stringWithFormat:@"maxs%d_owned.txt",self.numWords] evenMid:NO];
    }
        

    CountSubsequences ssc=[[CountSubsequences alloc] init] (readonly,dealloc,ivar=ssc)

    -(void)goOptsWithDictWordArray:(DictWordArray*)pwds {
        self.patternFilename=[NSString stringWithFormat:@"maxs%d_owned.txt",self.numWords];
        WPatternArray &pa=*self.patterns;

        BigUInt zero=BigUIntFunctions::zero();
        
        DictWordArray &wds=*pwds;
        
        IterateArray(DictWord,w,wds,
            w.lengthMask=0;
        );
        
        IterateArray(WPattern,p,pa,
            ULL msk=0;
            for (int ntaps=1,b=1;ntaps<28;ntaps++,b<<=1) {
                if ((TA_upperBound(p.counts)>=ntaps)&&BigUIntFunctions::isGreater(TA_A(p.counts,ntaps),zero)) msk|=b;
            }
            if (!(pIndex%10)) prnt(".");
            if (!(pIndex%1000)) {
                prnt("\nwds %d/%d\n",pIndex+1,pa.num());
            }
            
            //for (ULL b=0x8000000000000000LL;b;b>>=1) prnt("%c",msk&b?'*':'-');prnt("\n");
            
            int best[MAXWORDLEN];memset(best,0xff,sizeof(int)*MAXWORDLEN);
            int nbest=0;
            const char *sub,*sup;
            IterateArray(DictWord,w,wds,
                sup=w.word;sub=p.pattern;
                long len=strlen(sup);
                //prnt("%d %s %s\n",best[len],sup,sub);
                if (best[len]<0) {
                    while (*sup) sub+=((*sub)==((*(sup++))|('a'-'A')));
                    if (!*sub) {
                        best[len]=(int)wIndex;
                        nbest++;
                    }
                }
            );
            for (int len=0;len<MAXWORDLEN;len++) if (best[len]>=0) {
                wds.a[best[len]].lengthMask|=msk;
                //prnt("[%d]|=%qx>%qx ",best[len],msk,wds.a[best[len]].lengthMask);
            }
        );
    }

    -(void)goOpts {
        self.patternFilename=[NSString stringWithFormat:@"maxs%d_owned.txt",self.numWords];
        WPatternArray &pa=*self.patterns;

        Array<int> grouppis;
        Array<DWRD> groupMsks;
        Array<TinyArray<int> > groups;
        int N=(int)pa.num();
        BigUInt zero=BigUIntFunctions::zero();
        
        Wd *wds=self.words;
        
        groups.setUpperBound(N-1);
        groupMsks.setUpperBound(N-1);
        grouppis.setUpperBound(N-1);
        int Ni=0,Ni2=0;
        ContextIndex ci={0};
        QuickHashTable<int> ht(ci,-1);
        
        int Nw=self.numWords;

        IterateArray(WPattern,p,pa,
            DWRD msk=0;
            for (int ntaps=1,b=1;ntaps<28;ntaps++,b<<=1) {
                if ((TA_upperBound(p.counts)>=ntaps)&&BigUIntFunctions::isGreater(TA_A(p.counts,ntaps),zero)) msk|=b;
            }
            if (!(Ni2%10)) oprnt(".");
            if (!(Ni2%1000)) {
                oprnt("\nwds %d/%d, Ni:%d\n",Ni2+1,N,Ni);
            }
            int best[28];memset(best,0xff,sizeof(int)*28);
            int nbest=0;
            const char *sub,*sup;
            for (int i=0;i<Nw;i++) {
                sup=wds[i].word;sub=p.pattern;
                if (best[strlen(wds[i].word)]<0) {
                    while (*sup) sub+=((*sub)==(*(sup++)));
                    if (!*sub) {
                        best[strlen(wds[i].word)]=i;
                        nbest++;
                    }
                }
            }
            ULL hash=0;
            for (int len=0;len<28;len++) if (best[len]>=0) {
                hash+=obfuscateULL(best[len]);
            }
            int wasInd=ht[hash];
            if (wasInd==-1) {
                ht.add(hash,Ni);
                TinyArray<int> ta;
                TA_init(ta);
                TA_setUpperBound(ta,nbest-1);
                for (int len=0,bi=0;len<28;len++) if (best[len]>=0) {
                    TA_A(ta,bi)=best[len];
                    bi++;
                }
                groupMsks.a[Ni]=msk;
                groups.a[Ni]=ta;
                grouppis.a[Ni]=(int)pIndex;
                Ni++;
            }
            else groupMsks.a[wasInd]|=msk;
            Ni2++;
        );
        N=Ni;
        
        groups.setUpperBound(N-1);
        groupMsks.setUpperBound(N-1);
        grouppis.setUpperBound(N-1);
        
        Array<int> inds0,inds;
        Array<long> tmpa;
        
        inds0.setUpperBound(N-1);
        IterateArray(int,i,inds0,  i=(int)iIndex;);
        linearSort(int,inds0,inds,  -TA_num(groups.a[obj]),tmpa);
        
        
        int j=0;
        IterateArray(int,ind,inds,
            if (!(indIndex%10)) oprnt(".");
            if (!(indIndex%1000)) {
                oprnt("\nsubs %d/%d %s\n",indIndex+1,inds.num(),pa.a[grouppis.a[ind]].pattern);
            }
            
            bool hasSup=NO;
            for (int jj=0;jj<j;jj++) {
                if ((!(groupMsks.a[ind]&~groupMsks.a[inds.a[jj]]))&&arrayIsSubset(groups.a[ind],groups.a[inds.a[jj]])) {
                    hasSup=YES;break;
                }
            }
            if (!hasSup) {
                if (j<indIndex) inds.a[j]=ind;
                j++;
            }
        );
        inds.setUpperBound(j-1);
        
        IterateArray(int,ind,inds,
            prnt("[%ld]%s ",indIndex,pa.a[grouppis.a[ind]].pattern);
            for (DWRD msk=groupMsks.a[ind];msk;msk>>=1) prnt("%c",msk&1?'*':'-');
            IterateTAArray(int,ind2,groups.a[ind],  prnt(" %d:%s",ind2,wds[ind2].word););
            prnt("\n");
        );
        oprnt("%ld->%d->%d through subsets\n",pa.num(),N,j);
        



        NSString *fn=[NSString stringWithFormat:@"mp%d.bin",self.numWords];

        FILE *fil=fopen(fn.UTF8String,"wb");
        if (!fil) {
            printf("Could not open %s\n",fn.UTF8String);
        }
        else {
            bool debug=NO;
            IntArray a;
            int tmpi;
            ULL ull=0;BYT shft=0;
            printf("Writing to %s\n",fn.UTF8String);
             IterateArray(int,ind,inds,
                FilterTAArrayToNormalArray(int,i,groups.a[ind],    int,j,a,    YES,    j=i;);
                if (a.upperBound()) {
                    arrHeapSortb(int,a,   obja<objb   , 0,a.upperBound(),tmpi);
                }
                
                if (!groupMsks.a[ind]) continue;
                
                int minl=1;for (DWRD bit=0xfffffffe;bit&groupMsks.a[ind];bit<<=1,minl++);
                
                //WRITEBITS(minl,5,fil,ull,shft);
                int iwas=0;
                IterateArray(int,i,a,
                    int len;for (len=1;i-iwas>rightOnes[len*2];len++);
                    //WRITEBITS(len,4,fil,ull,shft);
                    //WRITEBITS(i-iwas,len*2,fil,ull,shft);
                );
                //WRITEBITS(0,4,fil,ull,shft);
            );
            //WRITEBITS(0,5,fil,ull,shft);
            if (shft) fwrite(&ull,8,1,fil);
            long Nb=ftell(fil);
            fclose(fil);
            printf("Wrote %ld bytes to %s\n",Nb,fn.UTF8String);
        }


        IterateArray(TinyArray<int>,ta,groups, TA_clear(ta););
    }
                    
            




wi type BigUInt
wi type SchemaCount

CountSubsequences
    BCArray_BigUInt countsByLength=[[BCArray_BigUInt alloc] init] (readonly,dealloc,ivar=countsByLength)
    BCArray_BigUInt dpcounts=[[BCArray_BigUInt alloc] init] (readonly,dealloc,ivar=dpcounts)
    BCArray_bool dpgot=[[BCArray_bool alloc] init] (readonly,dealloc,ivar=dpgot)
    -(void)dealloc {@-950 
        [self setUpperBound:-1 ofBigUIntArray:countsByLength];
        [self setUpperBound:-1 ofBigUIntArray:dpcounts];
    }

    -(init)init {}

    -(void)setUpperBound:(int)ub ofBigUIntArray:(BCArray_BigUInt*)a {
        int ubwas=a.upperBound;
        for (int i=ub+1;i<=ubwas;i++) TA_clear(a.a[i]);
        a.upperBound=ub;
        for (int i=ubwas+1;i<=ub;i++) TA_init(a.a[i]);
    }

    -(BCArray_BigUInt*)countsByLengthForString:(const char*)pc {
        int N=(int)strlen(pc);
        //prnt("N%d ",N);
        [self setUpperBound:N ofBigUIntArray:countsByLength];
        //prnt(". ");

        for (int i=0;i<countsByLength.num;i++) TA_clear(countsByLength.a[i]);
        //prnt(". ");
        countsByLength.a[0]=countsByLength.a[N]=BigUIntFunctions::one();
        //prnt(". ");
        for (int len=1;len<=N;len++) {
            //prnt("len%d ",len);
            [self setUpperBound:(N+1)*(N+1)-1 ofBigUIntArray:dpcounts];
            //prnt(". ");
            dpgot.upperBound=(N+1)*(N+1)-1;
            //prnt(". ");
            memset(dpgot.a,0,dpgot.num);
            //prnt(". ");
        
            [self goWithChars:pc N:N len:len at:-1 k:len];
             //prnt("o ");

            countsByLength.a[len]=dpcounts.a[(N+1)*len];
            //prnt(". ");
            TA_init(dpcounts.a[(N+1)*len]);
            //prnt(". ");
        }
        //prnt("c ");
        for (int i=0;i<dpcounts.num;i++) {TA_clear(dpcounts.a[i]);}
        //prnt("O ");
        return(countsByLength);
    }


    -(BigUInt&)goWithChars:(const char *)pc N:(int)N len:(int)len at:(int)at k:(int)k {
        int myi=(N+1)*k+(at+1);
        //printf(">> [%d(%d)] %d %d %d %d\n",myi,dpgot.a[myi],N,len,at,k);
        BigUInt &ret=dpcounts.a[myi];
        if (!dpgot.a[myi]) {
            TA_clear(ret);
            dpgot.a[myi]=YES;
            if (k>N-(at+1)) ret=BigUIntFunctions::zero();
            else if (k==0) ret=BigUIntFunctions::one();
            else {
                bool seen[256];memset(seen,0,256);
                BYT c;
                for (int at2=at+1;(c=pc[at2]);at2++) {
                    if (!seen[c]) {
                        seen[c]=YES;
                        BigUInt add=[self goWithChars:pc N:N len:len at:at2 k:k-1];
                        BigUIntFunctions::addInplace(ret,add);
                    }
                }
            }
        }
        //String s;
        //BigUIntFunctions::decimalStr(ret,s);
        //printf("<< %d %d %d %d = %s\n",N,len,at,k,s.a);
        return(ret);			
    }

    +(bool)subCounts:(BCArray_BigUInt*)sub from:(BCArray_BigUInt*)from {
        for (int i=0;i<sub.num;i++) {
            BigUInt bui=BigUIntFunctions::zero();
            if (i<from.num) bui=from.a[i];
            if (BigUIntFunctions::isGreater(sub.a[i],bui)) return(NO);
            if (i<from.num) BigUIntFunctions::subtractInplace(from.a[i],sub.a[i]);
        }
        return(YES);
    }

    +(bool)subSCCounts:(SchemaCount*)sub from:(SchemaCount*)from {
        for (int i=0;i<TA_num(*sub);i++) {
            BigUInt bui=BigUIntFunctions::zero();
            if (i<TA_num(*from)) bui=TA_A(*from,i);
            if (BigUIntFunctions::isGreater(TA_A(*sub,i),bui)) return(NO);
            if (i<TA_num(*from)) BigUIntFunctions::subtractInplace(TA_A(*from,i),TA_A(*sub,i));
        }
        return(YES);
    }


    +(bool)string:(const char*)sub isSubsequenceOf:(const char*)str {
        while (*sub) {
            while ((*str)&&(*str!=*sub)) str++;
            if (!*str) return(NO);
            sub++;
            str++;
        }
        return(YES);
    }

    +(bool)subCountsOfSubsequencesFromStringsAndCounts:(NSDictionary*)subs fromString:(NSString*)fromStr withCounts:(BCArray_BigUInt*)fromCounts {
        bool ret=YES;
        const char *str=fromStr.UTF8String;
        for (NSString *subStr in subs) {
            if ([CountSubsequences string:subStr.UTF8String isSubsequenceOf:str]) {
                if (![CountSubsequences subCounts:(BCArray_BigUInt*)[subs objectForKey:subStr] from:fromCounts]) ret=NO;
            }
        }
        return(ret);
    }

    BCString bcs=[[BCString alloc] init] (readonly,dealloc,ivar=bcs)
    NSMutableString countstr=[[NSMutableString alloc] init] (readonly,dealloc,ivar=countstr)

    -(NSString*)stringForCounts:(BCArray_BigUInt*)counts ret:(NSMutableString*)ret {
        if (!ret) ret=countstr;
        [ret setString:@""];
        for (int i=1;i<counts.num;i++) {
            BigUIntFunctions::decimalStr(counts.a[i],*bcs.cppString);
            if (i>1) [ret appendString:@" "];
            [ret appendFormat:@"%s",bcs.cppString->a];
        }
        return(ret);
    }

    -(NSString*)stringForSCCounts:(SchemaCount*)counts ret:(NSMutableString*)ret {
        if (!ret) ret=countstr;
        [ret setString:@""];
        for (int i=1;i<TA_num(*counts);i++) {
            BigUIntFunctions::decimalStr(TA_A(*counts,i),*bcs.cppString);
            if (i>1) [ret appendString:@" "];
            [ret appendFormat:@"%s",bcs.cppString->a];
        }
        //prnt("C: %s\n",ret.UTF8String);
        return(ret);
    }

"dict2.wi"



    
