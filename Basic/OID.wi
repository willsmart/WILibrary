

/*top:
#define OID_marker (0xbad0fad0dad0cad0LL)
#define __Derived_CClass__ (class_getName([self class]))
#define __Derived_Class__ [NSString stringWithFormat:@"%s",__Derived_CClass__]
#ifndef OWNER_TRACKING_ON
#define OWNER_TRACKING_ON NO
#endif
*/

"<pthread.h>"

<ThreadKey> "multi" "nac"
    -decl:{
        extern pthread_key_t ThreadKey_key_keyName;
        extern valueType getThreadValueNamedKeyName();
        extern valueType setThreadValueNamedKeyName(valueType v);
    }
    -decl:impl:{
        pthread_key_t ThreadKey_key_keyName=nil;
        valueType getThreadValueNamedKeyName() {
            if (!ThreadKey_key_keyName)  pthread_key_create(&ThreadKey_key_keyName,nil);
            return((valueType)pthread_getspecific(ThreadKey_key_keyName));
        }
        valueType setThreadValueNamedKeyName(valueType v) {
            if (!ThreadKey_key_keyName)  pthread_key_create(&ThreadKey_key_keyName,nil);
            valueType ret=(valueType)pthread_getspecific(ThreadKey_key_keyName);
            pthread_setspecific(key,(const void*)v);
            return(ret);
        }
    }

/*each:impl:
#ifdef _PrivateAccessMask_
#undef _PrivateAccessMask_
#endif
#define _PrivateAccessMask_ __private_access_thread_mask_in___ClassName__
*/

ThreadIDKey<ThreadKey> "keyName=>id" "valueType=>int" "nac"
    -decl:{
        extern int g_prevThreadId;
        int getThreadId();
        ULL getThreadMask();

        bool authorized_thread(ULL&mask);
        bool authorize_thread(ULL&mask);
        void deauthorize_thread(ULL&mask);
        #define privateaccess(...) do {bool __needdeauth=authorize_thread(_PrivateAccessMask_);{__VA_ARGS__;}if (__needdeauth) deauthorize_thread(_PrivateAccessMask_);} while (false)
    }
    -decl:impl:{
        int g_prevThreadId=0;
        ULL getThreadMask() {
            int ret=getThreadValueNamedId();
            if (!ret) setThreadValueNamedId(ret=++g_prevThreadId);
            return(1LL<<(ret-1));
        }
        int getThreadId() {
            int ret=getThreadValueNamedId();
            if (!ret) setThreadValueNamedId(ret=++g_prevThreadId);
            return(ret);
        }

        bool authorized_thread(ULL&mask) {
            ULL tmask=getThreadMask();
            if (!tmask) ERR("Too many threads for this implementation of publicreadonly properties (64)");
            else {
                if (mask&tmask) {
//                    mask&=~tmask;
                    return(YES);
                }
            }
            return(NO);
        }
        bool authorize_thread(ULL&mask) {
            if (mask&getThreadMask()) return(NO);
            else {
                mask|=getThreadMask();
                return(YES);
            }
        }
        void deauthorize_thread(ULL&mask) {
            mask&=~getThreadMask();
        }
    }

<ClassObject>
    ULL __private_access_thread_mask_in___ClassName__=0 (justivar,privateivar)





ClassCount "-Object" "fn:object"
    LL count=nil,nextID=nil
    NSString name=nil (readonly,dealloc,ivar=name)
    +(ClassCount*)classCount {
        return([[[ClassCount alloc] init] autorelease]);
    }
    -(init[super init])initWithName:(NSString*)aname {
        name=[aname retain];
        count=0;nextID=1;
    }
    NSString description={return([NSString stringWithFormat:@"%@x%qu",name,count]);}

type QuickHashTableOfClassCounts


/*decl:
    typedef QuickHashTable<ClassCount*> QuickHashTableOfClassCounts;
    extern QuickHashTable<ClassCount*> *g_classCountht;
    extern ClassCount *g_totalObjectCount;
    extern ClassCount *g_classCountForClass(Class clas);
*/
/*decl:impl:
    QuickHashTable<ClassCount*> *g_classCountht=nil;
    ClassCount *g_totalObjectCount=nil;
    ClassCount *g_classCountForClass(Class clas) {
        ULL hash=obfuscateHash((ULL)clas);
        ClassCount *ret=g_classCountht->find(hash);
        if (!ret) {
            g_classCountht->add(hash,ret=[[ClassCount alloc] initWithName:[NSString stringWithFormat:@"%s",class_getName(clas)]]);
        }
        return(ret);
    }
    template ManagedArray<QuickHashTableContext<ClassCount*> > QuickHashTableContext<ClassCount*>::contexts;
*/

Singletons<Ticker> "-Object" "fn:object"
    NSMutableArray typeCountHistory=[NSMutableArray array]
    QuickHashTableOfClassCounts *classCountht=nil (readonly)
    ClassCount totalObjectCount=nil (publicreadonly,dealloc,ivar=totalObjectCount)

    -(void)dealloc {
        {
            Array<ClassCount*> cca;
            g_classCountht->asArray(cca);
            IterateArray(ClassCount*,cc,cca,
                [cc release];
            );
            DELETE(QuickHashTable<ClassCount*>,g_classCountht);
        }
    }

    -(init) {@-800
        g_totalObjectCount=totalObjectCount=[[ClassCount alloc] initWithName:@"All classes"];
        ContextIndex ci={0};
        g_classCountht=classCountht=NEWCONSb(QuickHashTableOfClassCounts,(ci,nil,2048));
        @0
        for (int i=0;i<5;i++) [self.typeCountHistory addObject:[NSMutableDictionary dictionary]];
    }

    NSString description={@-999
        NSMutableString *ret=[NSMutableString stringWithFormat:@"\nx%qu Objects:\n",totalObjectCount.count];
        {
            Array<ClassCount*> cca;
            g_classCountht->asArray(cca);
            ClassCount *pcc;
            arrHeapSortb(ClassCount*,cca.a,obja.count>objb.count,0,cca.upperBound(),pcc);
            IterateArray(ClassCount*,cc,cca,
                NSString *name=cc.name;
                [ret appendFormat:@"%@    %@ x %qu << %u, %u, %u, %u, %u -- %d\n",
                    (int(cc.count)==
                    ((NSNumber*)[(NSDictionary*)[self.typeCountHistory objectAtIndex:1] objectForKey:name]).intValue?@"":@"**"),
                    name,cc.count,
                    ((NSNumber*)[(NSDictionary*)[self.typeCountHistory objectAtIndex:0] objectForKey:name]).intValue,
                    ((NSNumber*)[(NSDictionary*)[self.typeCountHistory objectAtIndex:1] objectForKey:name]).intValue,
                    ((NSNumber*)[(NSDictionary*)[self.typeCountHistory objectAtIndex:2] objectForKey:name]).intValue,
                    ((NSNumber*)[(NSDictionary*)[self.typeCountHistory objectAtIndex:3] objectForKey:name]).intValue,
                    ((NSNumber*)[(NSDictionary*)[self.typeCountHistory objectAtIndex:4] objectForKey:name]).intValue,
                    int(cc.count)-
                    ((NSNumber*)[(NSDictionary*)[self.typeCountHistory objectAtIndex:1] objectForKey:name]).intValue
                    ];
            );
        }
        @999 return(ret);
    }

    -(void)tick {
        [Log sendToLog:@"Singletons" format:@"Singletons at %@\n%@\n\n",((NSDate*)[NSDate date]).description,self.description];
        if (!self.online) prnt("%s\n",self.description.UTF8String);
        NSMutableDictionary *d=[(NSMutableDictionary*)[self.typeCountHistory objectAtIndex:4] retain];
        [self.typeCountHistory removeLastObject];
        [d removeAllObjects];

        Array<ClassCount*> cca;
        g_classCountht->asArray(cca);
        IterateArray(ClassCount*,cc,cca,
            NSString *key=cc.name;
            [d setObject:[NSNumber numberWithInt:(int)cc.count] forKey:key];
        );
        [self.typeCountHistory insertObject:d atIndex:0];
        [d release];
    }
    
"<execinfo.h>"

/*interfaces:
 
    extern id retainFn(NSObject *me,int &rc,int &arc);
    extern void releaseFn(NSObject *me,int &rc,int &arc,bool debugAutorelease);
    extern id autoreleaseFn(NSObject *me,int &rc,int &arc,bool debugAutorelease);
    extern void objInitFn(NSObject *me,int &rc,int &arc,LL &mei,LL &meci);
    extern void deallocFn(NSObject *me,int &rc,int &arc,LL &mei,LL &meci);
    extern NSString *g_objectName(id object);
    extern const char *g_cobjectName(id object);
    
*/
/*interfaces:impl:


    id retainFn(NSObject *me,int &rc,int &arc);
    void releaseFn(NSObject *me,int &rc,int &arc);
    id autoreleaseFn(NSObject *me,int &rc,int &arc);

 
    void retainFn(NSObject *me,LL objectContext,int &rc,int &arc) {
        rc++;
        objectRetained(me);
    }
    
    void releaseFn(NSObject *me,int &rc,int &arc,bool debugAutorelease) {
        rc--;
        bool isAutorelease=NO;
        if (debugAutorelease) {
            void* callstack[8];
            int i, frames = backtrace(callstack, 6);
            char** strs = backtrace_symbols(callstack, frames);
            //for (i = 0; i < frames; ++i) {
            //    printf("%s\n", strs[i]);
            //}
            for (i = 2; i < frames; ++i) {
                if (strstr(strs[i]," release]")) break;
                else if (strstr(strs[i],"AutoreleasePoolP")) {isAutorelease=YES;arc--;break;}
            }
            //prnt("%s\n",isAutorelease?" -- autorelease\n":" -- standard release\n");
            free(strs);
            if (isAutorelease) {
                objectAutoreleaseCollected(me);
                arc--;
            }
            else objectReleased(me);
        }
        else objectReleased(me);
     }
    
    void autoreleaseFn(NSObject *me,int &rc,int &arc,bool debugAutorelease) {
        if (debugAutorelease) {
            arc++;
            objectAutoreleasePending(me);
        }
    }

    void objInitFn(NSObject *me,int &rc,int &arc,LL &mei,LL &meci) {
        rc=1;arc=0;
        ClassCount *c=g_classCountForClass([me class]);
        c.count++;
        meci=c.nextID++;
        mei=g_singletons.totalObjectCount.nextID++;
        g_singletons.totalObjectCount.count++;
        objectAllocated(me);
    }
 
    void deallocFn(NSObject *me,int &rc,int &arc,LL &mei,LL &meci) {
        if (mei==0) {
            ERR("!!!! error with object %p of type %s, the object was never inited",me,class_getName([me class]));
            return;
        }
        if (mei==-1) {
            ERR("!!!! error with object %p of type %s, the object seems to be being dealloced again",me,class_getName([me class]));
            return;
        }
        if (rc||arc) {
            ERR("!!!! error with object %p of type %s, the object has non-zero rc or arc at time of deallocation",me,class_getName([me class]));
            return;
        }

        ClassCount *c=g_classCountForClass([me class]);
        if (c.count<=0) {
            ERR("!!!! error with counts of type %s, the object %p is being deallocated but the count of %s's is negative or zero",class_getName([me class]),me,class_getName([me class]));
            return;
        }
        c.count--;
 
        objectDeallocated:mei(me);
        mei=meci=-1;
    }
    NSString *g_objectName(id object) {
        if ([(NSObject*)object respondsToSelector:@selector(objectName)]) return([(NSObject<Object>*)object objectName]);
        else return([NSString stringWithFormat:@"%s:%p",class_getName([(NSObject*)object class]),object]);
    }
    const char *g_cobjectName(id object) {
        return([g_objectName(object) cStringUsingEncoding:NSASCIIStringEncoding]);
    }
*/

<Object>
    LL objectIDInClass=nil,objectIDInTotal=nil (readonly)

    bool isZombie=nil (readonly)

    bool debugAutorelease=nil

    int ___rc=nil,___arc=nil

    LL __owner_context=nil (ivar=__owner_context)

    -(init) {@-996 debugAutorelease=YES;}
    -(init) {@-995 objInitFn(self,___rc,___arc,objectIDInTotal,objectIDInClass);
    }
    -(void)dealloc {@998 deallocFn(self,___rc,___arc,objectIDInTotal,objectIDInClass);
        isZombie=YES;
#if defined(LONGLIVEZOMBIES) || defined(LONGLIVEZOMBIES___WI_CLASS__)
        if (YES) return;
#endif
    }

    -(id)retain {@-900 retainFn(self,___rc,___arc); @999 return([super retain]);}
    -(void)release {@-900 releaseFn(self,___rc,___arc,debugAutorelease); @990 [super release];}
    -(id)autorelease {@-900 autoreleaseFn(self,___rc,___arc,debugAutorelease); @990 return([super autorelease]);}

    NSString description={@-999 
        NSMutableString *ret=self.objectName;
        @999 return(ret);
    }
    NSMutableString objectName={@-999 
        NSMutableString *ret=nil;
        @-100 ret=[NSMutableString stringWithFormat:@"[%qu:%p]%s#%qu",objectIDInTotal,self,__Derived_CClass__,objectIDInClass];
        @999 return(ret);
    }
    constchar *cdescription={return([self.description cStringUsingEncoding:NSASCIIStringEncoding]);}
    constchar *cobjectName={return([self.objectName cStringUsingEncoding:NSASCIIStringEncoding]);}









    
Singletons
    Trace trace={return(!trace?trace=[[Trace alloc] init]:trace);}=nil(publicreadonly,dealloc,ivar=trace)
    
"<pthread.h>"
/*interfaces:
    extern ULL g_sequence;
    extern Trace *g_trace;
    #define ADDTRACE(__trcfnnm) TraceFunctionTracker __functionTracker((((const void*)self)!=(const void*)g_trace)&&(((const void*)self)!=(const void*)[g_trace class]),__trcfnnm);
    
    
    class TraceFunctionTracker {
        public:
            int depth;
            static pthread_key_t key;
            TraceFunctionTracker(bool en,const char *fnName) {
                if (!en) depth=-1;
                else {
                    if (!key)  (&key,nil);
                    depth=((int)pthread_getspecific(key))+1;
                    if (depth<0) depth=0;
                    pthread_setspecific(key,(const void*)depth);
                    [g_trace addTraceCString:fnName atDepth:depth];
                }
            }
            ~TraceFunctionTracker() {
                if (depth>=0) {
                    [g_trace finishDepth:depth];
                    pthread_setspecific(key,(const void*)(depth-1));
                }
            }
    };
    extern int g_numNamedThreads;
    
    
    void addTrace(NSString *trace,int depth);
    void addTraceCString(const char *trace,int depth);
    void finishDepth(int depth);
    void ADDOWNER(id object,id owner);
    void REMOVEOWNER(id object,id owner);
    void objectRetained(id object);
    void objectReleased(id object);
    void objectAutoreleasePending(id object);
    void objectAutoreleaseCollected(id object);
    void objectAllocated(id object);
    void objectDeallocated(id object);
 
*/
/*interfaces:impl:
    ULL g_sequence=0;
    Trace *g_trace=nil;
    NSString *g_newTraces=nil;
    pthread_key_t TraceFunctionTracker::key=nil;
    int g_numNamedThreads=0;
    
    
    
    void addTrace(NSString *trace,int depth) {
        [g_newTraces appendFormat:@"[%d,%qu,%f,\"%@\",\"%@\"],\n",depth,g_sequence++,CACurrentMediaTime(),
            [Trace threadNameJSON],
            trace.JSONString];
    }
    
    void addTraceCString(const char *trace,int depth) {
        [g_newTraces appendFormat:@"[%d,%qu,%f,\"%@\",\"%S\"],\n",depth,g_sequence++,CACurrentMediaTime(),
            [Trace threadNameJSON],
            [NSString JSONunicharsStringForCString:trace withLength:(int)strlen(trace) useTmpDataObject:nil retLength:nil]];
    }
    
    void finishDepth(int depth) {
        [g_newTraces appendFormat:@"[%d,%qu,%f,\"%@\"],\n",depth,g_sequence++,CACurrentMediaTime(),
            [__Class__ threadNameJSON]];
    }

    void ADDOWNER(id object,id owner) {
        [g_newTraces appendFormat:@"[-1,%qu,%f,%qx,%qx,\"%s\"],\n",g_sequence++,CACurrentMediaTime(),
            (ULL)owner,(ULL)object,class_getName(object.class)];
    }
    void REMOVEOWNER(id object,id owner) {
        [g_newTraces appendFormat:@"[-2,%qu,%f,%qx,%qx],\n",g_sequence++,CACurrentMediaTime(),
            (ULL)owner,(ULL)object];
    }

    void objectRetained(id object) {
        [g_newTraces appendFormat:@"[-3,%qu,%f,%qx,\"%s\"],\n",g_sequence++,CACurrentMediaTime(),
            (ULL)object,class_getName(object.class)];
    }
    void objectReleased(id object) {
        [g_newTraces appendFormat:@"[-4,%qu,%f,%qx],\n",g_sequence++,CACurrentMediaTime(),
            (ULL)object];
    }
    void objectAutoreleasePending(id object) {
        [g_newTraces appendFormat:@"[-5,%qu,%f,%qx],\n",g_sequence++,CACurrentMediaTime(),
            (ULL)object];
    }
    void objectAutoreleaseCollected(id object) {
        [g_newTraces appendFormat:@"[-6,%qu,%f,%qx],\n",g_sequence++,CACurrentMediaTime(),
            (ULL)object];
    }
    void objectAllocated(id object) {
        [g_newTraces appendFormat:@"[-7,%qu,%f,%qx,\"%s\"],\n",g_sequence++,CACurrentMediaTime(),
            (ULL)object,class_getName(object.class)];
    }
    void objectDeallocated(id object) {
        [g_newTraces appendFormat:@"[-4,%qu,%f,%qx],\n",g_sequence++,CACurrentMediaTime(),
            (ULL)object];
    }
 
*/
Trace<Ticker,BaseObject>
    +(NSString*)callStackStringFromDepth:(int)fromDepth toDepth:(int)toDepth {
        NSMutableString *ret=[NSMutableString string];
        NSArray *__a=[NSThread callStackSymbols];
        //NSLog(__a.description);
        for (int d=1,dd=0;(d<__a.count)&&(dd<=toDepth);d++) {
            NSString *s=[__a objectAtIndex:d];
            NSUInteger st=[s rangeOfString:@"["].location;
            NSUInteger en=[s rangeOfString:@"]" options:NSBackwardsSearch].location;
            if ((st!=NSNotFound)&&(en!=NSNotFound)&&(en>st)) {
                s=[s substringWithRange:NSMakeRange(st-1,en+1-(st-1))];
                if ([s isEqualToString:@"-[EndpointS didAddObject:]"]) [ret appendFormat:@" ES+ "];
                else if ([s isEqualToString:@"-[EndpointS addObject:]"]||[s isEqualToString:@"-[EndpointS _addObject:]"]) {}
                else if ([s isEqualToString:@"-[MutableSet didAddObject:]"]) [ret appendFormat:@" MS+ "];
                else if ([s isEqualToString:@"-[MutableSet addObject:]"]||[s isEqualToString:@"-[MutableSet _addObject:]"]) {}
                else if ([s isEqualToString:@"-[EndpointS willRemoveObject:]"]) [ret appendFormat:@" ES- "];
                else if ([s isEqualToString:@"-[EndpointS removeObject:]"]||[s isEqualToString:@"-[EndpointS _removeObject:]"]) {}
                else if ([s isEqualToString:@"-[MutableSet willRemoveObject:]"]) [ret appendFormat:@" MS- "];
                else if ([s isEqualToString:@"-[MutableSet removeObject:]"]||[s isEqualToString:@"-[MutableSet _removeObject:]"]) {}
                else if ([s isEqualToString:@"-[EndpointA didInsertObject:withIndex:]"]) [ret appendFormat:@" EA+ "];
                else if ([s isEqualToString:@"-[EndpointA insertObject:atIndex:]"]||[s isEqualToString:@"-[EndpointA _insertObject:withIndex:]"]) {}
                else if ([s isEqualToString:@"-[MutableArray didInsertObject:withIndex:]"]) [ret appendFormat:@" MA+ "];
                else if ([s isEqualToString:@"-[MutableArray insertObject:withIndex:]"]||[s isEqualToString:@"-[MutableArray _insertObject:withIndex:]"]) {}
                else if ([s isEqualToString:@"-[EndpointA willRemoveObject:atIndex:]"]) [ret appendFormat:@" EA- "];
                else if ([s isEqualToString:@"-[EndpointA removeObject:atIndex:]"]||[s isEqualToString:@"-[EndpointA _removeObject:atIndex:]"]) {}
                else if ([s isEqualToString:@"-[MutableArray willRemoveObject:atIndex:]"]) [ret appendFormat:@" MA- "];
                else if ([s isEqualToString:@"-[MutableArray removeObject:atIndex:]"]||[s isEqualToString:@"-[MutableArray _removeObject:atIndex:]"]) {}
                else {
                    if (dd>=fromDepth) {
                        [ret appendFormat:@" -- %@",s];
                    }
                    dd++;
                }
            }
        }
        return(ret);
    }
    

    //NSMutableData tmpJSONData=[[NSMutableData alloc] init] (readonly,dealloc,ivar=tmpJSONData)
    
    NSMutableString *nwTraces=[[NSMutableString alloc] init] (readonly,dealloc,ivar=newTraces)
    NSMutableString *nwTraces2=[[NSMutableString alloc] init] (readonly,dealloc,ivar=newTraces2)

    -(void)start {g_newTraces=newTraces;g_trace=self;[self startWithInterval:0.5];}
    -(void)stop {@100 g_trace=nil;}
    
    bool savingTrace={return(v_tim!=nil);}
    
    +(NSString*)threadNameJSON {
        NSString *nm=(NSString*)[[NSThread currentThread].threadDictionary objectForKey:@"jsonname"];
        if (!nm) {
            [[NSThread currentThread].threadDictionary setObject:nm=[[NSString stringWithFormat:@"%d%@",++g_numNamedThreads,[NSThread currentThread].name] JSONString] forKey:@"jsonname"];
        }
        return(nm);
    }


    bool not_first=nil

    -(void)tick {
        g_trace=self;
        
        
        [newTraces2 setString:@""];
        NSMutableString *tmp=newTraces;g_newTraces=newTraces=newTraces2;newTraces2=tmp;
        
        if (newTraces2.length) {
            NSURL *url=[NSURL URLWithString:[g_singletons.homeURLPrefix stringByAppendingFormat:@"savetrace.php?fn=%@&fst=%d",g_singletons.styleName,not_first?0:1]];
            [[newTraces2 dataUsingEncoding:NSUTF8StringEncoding] sendAsBodyOfPOSTRequestWithURL:url returningResponse:nil error:nil];
            not_first=1;
        }

        [newTraces2 setString:newTraces];
        newTraces2=newTraces;g_newTraces=newTraces=tmp;
    }
    
    
    
    
    
    










    
Singletons
    ObjectGraph objectGraph={return(!objectGraph?objectGraph=[[ObjectGraph alloc] init]:objectGraph);}=nil(publicreadonly,dealloc,ivar=objectGraph)
    
"<pthread.h>"
/*interfaces:
    extern ObjectGraph *g_objectGraph;
    #define OBJOWN(__owner,__obj,__c) [g_objectGraph object:__owner ownsObject:__obj count:__c]
*/
/*interfaces:impl:
    ObjectGraph *g_objectGraph=nil;
*/
ObjectGraph<Ticker,BaseObject>
    NSMutableString *nwEdits=[[NSMutableString alloc] init] (readonly,dealloc,ivar=newEdits)
    NSMutableString *nwEdits2=[[NSMutableString alloc] init] (readonly,dealloc,ivar=newEdits2)

    -(void)start {g_objectGraph=self;[self startWithInterval:0.5];}
    -(void)stop {@100 g_objectGraph=nil;}
    
    bool savingGraph={return(v_tim!=nil);}

    -(void)object:(LL)owner ownsObject:(LL)object count:(int)count {
        [newEdits appendFormat:@"[%qu,%f,%qu,%qu,%d],\n",g_sequence++,CACurrentMediaTime(),owner,object,count];
    }

    bool not_first=nil

    -(void)tick {
        g_objectGraph=self;
        
        [newEdits2 setString:@""];
        NSMutableString *tmp=newEdits;newEdits=newEdits2;newEdits2=tmp;
        
        if (newEdits2.length) {
            NSURL *url=[NSURL URLWithString:[g_singletons.homeURLPrefix stringByAppendingFormat:@"saveobjectgraph.php?fn=%@&fst=%d",g_singletons.styleName,not_first?0:1]];
            [[newEdits2 dataUsingEncoding:NSUTF8StringEncoding] sendAsBodyOfPOSTRequestWithURL:url returningResponse:nil error:nil];
            not_first=1;
        }

        [newEdits2 setString:newEdits];
        newEdits2=newEdits;newEdits=tmp;
    }
    







    

<DerivedObject> "-Object"
    -(id)retain {@999 return([super retain]);}
    -(void)release {@999 [super release];}
    -(id)autorelease {@999 return([super autorelease]);}

ObjectPointer<ObjectEquateAndCopy> "-Object" "fn:object"
    LL objectIDInTotal=nil (readonly)
    -(init[super init])initWithObjectID:(LL)aobjectIDInTotal {
        objectIDInTotal=aobjectIDInTotal;
    }
    
<ObjectEquate>
    LL objectIDInTotal (readonly)
    -(BOOL)isEqual:(id)obj {@-999 
        bool ret=(obj==self)||
                    ([obj respondsToSelector:@selector(objectIDInTotal)]&&
                    (((NSObject<ObjectEquate>*)obj).objectIDInTotal==objectIDInTotal));
        @999 return(ret);
    }
    -(NSUInteger)hash {return((NSUInteger)obfuscateULL(objectIDInTotal));}

<ObjectEquateAndCopy:NSCopying,ObjectEquate>
    -(id)copyWithZone:(NSZone*)zone {
        return([[ObjectPointer allocWithZone:zone] initWithObjectID:objectIDInTotal]);
    }








