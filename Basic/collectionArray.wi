
NSArray<WeakNSCollection> "__MutableClass__=>NSMutableArray"
    CollectionWeakness weakness
        CollectionWeakness __block ret=CollectionIsEmpty;
        [self enumerateObjectsWithOptions:0 usingBlock:^(id object,NSUInteger index,BOOL *stop) {
            if (((ret=(CollectionWeakness)(ret|([object isWeakSelf]?CollectionIsWeak:CollectionIsStrong))))==CollectionIsWeakAndStrong) *stop=YES;
        }];
        return ret;

    NSArray* asWeak
        CollectionWeakness weakness=self.weakness;
        if (weakness&CollectionIsStrong) {
            NSMutableArray __block *ret=[NSMutableArray arrayWithCapacity:self.count];
            [self enumerateObjectsWithOptions:0 usingBlock:^(id object,NSUInteger index,BOOL *stop) {
                [ret addObject:([object isWeakSelf]?object:[object weakSelf])];
            }];
            return(ret);
        }
        else return(self);

    NSArray* asStrong
        CollectionWeakness weakness=self.weakness;
        if (weakness&CollectionIsWeak) {
            NSMutableArray __block *ret=[NSMutableArray arrayWithCapacity:self.count];
            [self enumerateObjectsWithOptions:0 usingBlock:^(id object,NSUInteger index,BOOL *stop) {
                id addObject=([object isWeakSelf]?[object strongSelf]:object);
                [ret addObject:addObject?addObject:NSNull.null];
            }];
            return(ret);
        }
        else return(self);




MutableArrayMirrorTesterImpl:NSMutableArray <MutableArrayMirrorTester> {}



WeakMutableArrayMirrorTesterImpl:NSMutableArray <MutableArrayMirrorTester,WeakCollection,MutableArray> {}







<Array>
    readonly:
        NSArray __array=0
        Int weakObjectCount=0
    bool insertsWeakObjectsByDefault=0
    CollectionWeakness weakness=
        {return(self.count?(weakObjectCount?(weakObjectCount==self.count?CollectionIsWeak:CollectionIsWeakAndStrong):CollectionIsWeak):CollectionIsEmpty);}
        -v{}

    void countWeakObjects {
        Int c=0;
        for (NSObject *o in __array) if (o.isWeakSelf) c++;
        weakObjectCount=c;
    }


    // initializing a set

    Self init {
        @-100 __array=[[NSArray alloc] init];
    }
    Self initWithCoder:(NSCoder*)coder super:init {
        @-100 __array=[[NSArray alloc] initWithCoder:coder];
        if (insertsWeakObjectsByDefault) __array=__array.weakCopy;
        @-99[self countWeakObjects];
    }
    Self initWithArray:(NSArray*)array super:init {
        @-100 __array=(insertsWeakObjectsByDefault?array.weakCopy:[[NSArray alloc] initWithArray:array]);
        @-99[self countWeakObjects];
    }
    Self initWithArray:(NSArray*)array copyItems:(BOOL)copy super:init {
        @-100 __array=[[NSArray alloc] initWithArray:array copyItems:copy];
        if (insertsWeakObjectsByDefault) __array=__array.weakCopy;
        @-99[self countWeakObjects];
    }
    Self initWithContentsOfFile:(NSString*)file super:init {
        @-100 __array=[[NSArray alloc] initWithContentsOfFile:file];
        if (insertsWeakObjectsByDefault) __array=__array.weakCopy;
        @-99[self countWeakObjects];
    }
    Self initWithContentsOfURL:(NSURL*)url super:init {
        @-100 __array=[[NSArray alloc] initWithContentsOfURL:url];
        if (insertsWeakObjectsByDefault) __array=__array.weakCopy;
        @-99[self countWeakObjects];
    }
    Self initWithObjects:(id*)objects count:(Unsigned)count super:init {
        @-100 __array=[[NSArray alloc] initWithObjects:objects count:count];
        if (insertsWeakObjectsByDefault) __array=__array.weakCopy;
        @-99[self countWeakObjects];
    }


    void encodeWithCoder:(NSCoder*)coder {
        [__array encodeWithCoder:coder];
    }

    id copyWithZone:(NSZone*)zone {
        return([[ImmutableArray allocWithZone:zone] initWithArray:__array]);
    }
    id mutableCopyWithZone:(NSZone*)zone {
        return([[MutableArray allocWithZone:zone] initWithArray:__array]);
    }

    Unsigned countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(__unsafe_unretained id*)stackbuf count:(Unsigned)len {
        return([__array countByEnumeratingWithState:state objects:stackbuf count:len]);
    }



    // Creating an array
    __WIClass__* +array {return([[__WIClass__ alloc] init]);}
    __WIClass__* +arrayWithArray:(NSArray*)array {return([[__WIClass__ alloc] initWithArray:array]);}
    __WIClass__* +arrayWithContentsOfFile:(NSString*)file {return([[__WIClass__ alloc] initWithContentsOfFile:file]);}
    __WIClass__* +arrayWithContentsOfURL:(NSURL*)url {return([[__WIClass__ alloc] initWithContentsOfURL:url]);}
    __WIClass__* +arrayWithObject:(id)object {return([[__WIClass__ alloc] initWithObjects:&object count:1]);}
    //__WIClass__* +arrayWithObjects:( {return([[__WIClass__ alloc] init]);}
    __WIClass__* +arrayWithObjects:(id*)objects count:(Unsigned)count {return([[__WIClass__ alloc] initWithObjects:objects count:count]);}






    //Querying an Array
    BOOL containsObject:(id)object {return([__array containsObject:object]);}
    Unsigned count={return([__array count]);} (atomic)
    void getObjects:(__unsafe_unretained id[])aBuffer range:(NSRange)aRange {
        [__array getObjects:aBuffer range:aRange];
        if (weakObjectCount) for (Int i=aRange.length+aRange.location-1;i>=aRange.location;i--) aBuffer[i]=[aBuffer[i] strongSelf];
    }
    id lastObject={return(weakObjectCount?[__array.lastObject strongSelf]:__array.lastObject);}
    id objectAtIndex:(Unsigned)index {
        if (index>=__array.count) ERR("Index %d is out of bounds [0,%d)",int(index),int(__array.count));
        return(weakObjectCount?[__array[index] strongSelf]:__array[index]);
    }
    NSArray* objects {
        if (weakObjectCount) {
            NSMutableArray *mret=nil;
            Int i=0;
            for (NSObject *o in __array) {
                if (o.isWeakSelf) {
                    if (!mret) mret=__array.mutableCopy;
                    [mret replaceObjectAtIndex:i withObject:[o strongSelf]];
                }
                i++;
            }
            return(mret?mret.copy:__array);
        }
        else return(__array);
    }
    NSArray* objectsAtIndexes:(NSIndexSet*)indexes {
        if (weakObjectCount) {
            NSMutableArray *mret=nil;
            NSArray *ret=[__array objectsAtIndexes:indexes];
            Int i=0;
            for (NSObject *o in ret) {
                if (o.isWeakSelf) {
                    if (!mret) mret=__array.mutableCopy;
                    [mret replaceObjectAtIndex:i withObject:[o strongSelf]];
                }
                i++;
            }
            return(mret?mret.copy:ret);
        }
        else return([__array objectsAtIndexes:indexes]);
    }
    NSEnumerator objectEnumerator={return([__array objectEnumerator]);}
    NSEnumerator reverseObjectEnumerator={return([__array reverseObjectEnumerator]);}


    //Finding Objects in an Array
    Unsigned indexOfObject:(id)object {
        return([__array indexOfObject:object]);
    }
    Unsigned indexOfObject:(id)object inRange:(NSRange)range {
        return([__array indexOfObject:object inRange:range]);
    }
    Unsigned indexOfObjectIdenticalTo:(id)object {
        if (weakObjectCount) {
            return(MIN([__array indexOfObjectIdenticalTo:[object strongSelf]],[__array indexOfObjectIdenticalTo:[object weakSelf]]));
        }
        else return([__array indexOfObjectIdenticalTo:object]);
    }
    Unsigned indexOfObjectIdenticalTo:(id)object inRange:(NSRange)range {
        if (weakObjectCount) {
            return(MIN([__array indexOfObjectIdenticalTo:[object strongSelf] inRange:range],[__array indexOfObjectIdenticalTo:[object weakSelf] inRange:range]));
        }
        else return([__array indexOfObjectIdenticalTo:object inRange:range]);
    }
    Unsigned indexOfObjectPassingTest:(BOOL (^)(id obj, Unsigned idx, BOOL *stop))predicate {
        return([__array indexOfObjectPassingTest:predicate]);
    }
    Unsigned indexOfObjectWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (^)(id obj, Unsigned idx, BOOL *stop))predicate {
        return([__array indexOfObjectWithOptions:opts passingTest:predicate]);
    }
    Unsigned indexOfObjectAtIndexes:(NSIndexSet *)indexSet options:(NSEnumerationOptions)opts passingTest:(BOOL (^)(id obj, Unsigned idx, BOOL *stop))predicate {
        return([__array indexOfObjectAtIndexes:indexSet options:opts passingTest:predicate]);
    }
    NSIndexSet* indexesOfObjectsPassingTest:(BOOL (^)(id obj, Unsigned idx, BOOL *stop))predicate {
        return([__array indexesOfObjectsPassingTest:predicate]);
    }
    NSIndexSet* indexesOfObjectsWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (^)(id obj, Unsigned idx, BOOL *stop))predicate {
        return([__array indexesOfObjectsWithOptions:opts passingTest:predicate]);
    }
    NSIndexSet* indexesOfObjectsAtIndexes:(NSIndexSet *)indexSet options:(NSEnumerationOptions)opts passingTest:(BOOL (^)(id obj, Unsigned idx, BOOL *stop))predicate {
        return([__array indexesOfObjectsAtIndexes:indexSet options:opts passingTest:predicate]);
    }
    Unsigned indexOfObject:(id)obj inSortedRange:(NSRange)r options:(NSBinarySearchingOptions)opts usingComparator:(NSComparator)cmp {
        return([__array indexOfObject:obj inSortedRange:r options:opts usingComparator:cmp]);
    }


    //Sending Messages to Elements
    void makeObjectsPerformSelector:(SEL)selector {
        [__array makeObjectsPerformSelector:selector];
    }
    void makeObjectsPerformSelector:(SEL)selector withObject:(id)object {
        [__array makeObjectsPerformSelector:selector withObject:object];
    }
    void enumerateObjectsUsingBlock:(void (^)(id obj, Unsigned idx, BOOL *stop))block {
        [__array enumerateObjectsUsingBlock:block];
    }
    void enumerateObjectsWithOptions:(NSEnumerationOptions)opts usingBlock:(void (^)(id obj, Unsigned idx, BOOL *stop))block {
        [__array enumerateObjectsWithOptions:opts usingBlock:block];
    }
    void enumerateObjectsAtIndexes:(NSIndexSet *)indexSet options:(NSEnumerationOptions)opts usingBlock:(void (^)(id obj, Unsigned idx, BOOL *stop))block {
        [__array enumerateObjectsAtIndexes:indexSet options:opts usingBlock:block];
    }


    //Comparing Arrays
    id firstObjectCommonWithArray:(NSArray*)array {
        return([__array firstObjectCommonWithArray:array]);
    }
    BOOL isEqualToArray:(NSArray*)array {
        return([__array isEqualToArray:array]);
    }


    //Deriving New Arrays
    NSArray* arrayByAddingObject:(id)object {
        return([self.objects arrayByAddingObject:object]);
    }
    NSArray* arrayByAddingObjectsFromArray:(NSArray*)array {
        return([self.objects arrayByAddingObjectsFromArray:array]);
    }
    NSArray* filteredArrayUsingPredicate:(NSPredicate *)predicate {
        return([self.objects filteredArrayUsingPredicate:predicate]);
    }
    NSArray* subarrayWithRange:(NSRange)r {
        return([self.objects subarrayWithRange:r]);
    }


    //Sorting
    NSData* sortedArrayHint {
        return([__array sortedArrayHint]);
    }
    NSArray * sortedArrayUsingFunction:(Int (*)(id, id, void *))comparator context:(void *)context {
        return([self.objects sortedArrayUsingFunction:comparator context:context]);
    }
    NSArray * sortedArrayUsingFunction:(Int (*)(id, id, void *))comparator context:(void *)context hint:(NSData *)hint {
        return([self.objects sortedArrayUsingFunction:comparator context:context hint:hint]);
    }
    NSArray * sortedArrayUsingDescriptors:(NSArray *)sortDescriptors {
        return([self.objects sortedArrayUsingDescriptors:sortDescriptors]);
    }
    NSArray* sortedArrayUsingSelector:(SEL)selector {
        return([self.objects sortedArrayUsingSelector:selector]);
    }
    NSArray * sortedArrayUsingComparator:(NSComparator)cmptr {
        return([self.objects sortedArrayUsingComparator:cmptr]);
    }
    NSArray * sortedArrayWithOptions:(NSSortOptions)opts usingComparator:(NSComparator)cmptr {
        return([self.objects sortedArrayWithOptions:opts usingComparator:cmptr]);
    }


    //Working with String Elements
    NSString * componentsJoinedByString:(NSString *)separator {
        return([__array componentsJoinedByString:separator]);
    }


    //Creating a Description
    NSString description={return([__array description]);}
    NSString * descriptionWithLocale:(id)locale {
        return([self.objects descriptionWithLocale:locale]);
    }
    NSString * descriptionWithLocale:(id)locale indent:(Unsigned)level {
        return([self.objects descriptionWithLocale:locale indent:level]);
    }
    BOOL writeToFile:(NSString *)path atomically:(BOOL)flag {
        return([self.objects writeToFile:path atomically:flag]);
    }
    BOOL writeToURL:(NSURL *)url atomically:(BOOL)flag {
        return([self.objects writeToURL:url atomically:flag]);
    }


    //Collecting Paths
    NSArray * pathsMatchingExtensions:(NSArray *)filterTypes {
        return([self.objects pathsMatchingExtensions:filterTypes]);
    }


    //Key-Value Observing
    void addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context {
        [__array addObserver:observer forKeyPath:keyPath options:options context:context];
    }
    void removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath {
        [__array removeObserver:observer forKeyPath:keyPath];
    }
    void removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(void *)context {
        [__array removeObserver:observer forKeyPath:keyPath context:context];
    }
    void removeObserver:(NSObject *)observer fromObjectsAtIndexes:(NSIndexSet*)indexes forKeyPath:(NSString *)keyPath context:(void *)context {
        [__array removeObserver:observer fromObjectsAtIndexes:indexes forKeyPath:keyPath context:context];
    }
    void addObserver:(NSObject *)observer toObjectsAtIndexes:(NSIndexSet*)indexes forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context {
        [__array addObserver:observer toObjectsAtIndexes:indexes forKeyPath:keyPath options:options context:context];
    }
    void removeObserver:(NSObject *)observer fromObjectsAtIndexes:(NSIndexSet*)indexes forKeyPath:(NSString *)keyPath {
        [__array removeObserver:observer fromObjectsAtIndexes:indexes forKeyPath:keyPath];
    }


    //Key-Value Coding
    void setValue:(id)value forKey:(NSString *)key {
        [__array setValue:value forKey:key];
    }
    id valueForKey:(NSString*)key {
        return([__array valueForKey:key]);
    }












<MutableArrayDelegate>
    NSArray delegateForArray=nil (assign,ivar=delegateForArray)
    void delegateForArrayChanged {}

    readonly: <MutableArrayDelegate> arrayDelegate=nil
    void addDelegate:(NSObject<MutableArrayDelegate>*)v {
        if (v.arrayDelegate) return;
        if (v==self) return;
        if (arrayDelegate) [arrayDelegate addDelegate:v];
        else {
            arrayDelegate=v;
            v.delegateForArray=self.delegateForArray;
            [v delegateForArrayChanged];
        }
    }
    void removedDelegate {@-100arrayDelegate=nil;}
    void removeDelegate:(NSObject<MutableArrayDelegate>*)v {
        if (arrayDelegate) {
            if (arrayDelegate==v) {
                v.delegateForArray=nil;
                arrayDelegate=v.arrayDelegate;
                [v removedDelegate];
                [v delegateForArrayChanged];
            }
            else [arrayDelegate removeDelegate:v];
        }
    }

    void willTryToAddObjectsWithCount:(Unsigned)count {
        @100 [arrayDelegate willTryToAddObjectsWithCount:count];
    }
    void willRemoveObjectsWithCount:(Unsigned)count {
        @100 [arrayDelegate willRemoveObjectsWithCount:count];
    }
    bool shouldAddObject:(id)object makeWeak:(bool&)weak {@-999
        bool ret=YES;
        @100 if (ret&&arrayDelegate) ret=[arrayDelegate shouldAddObject:object makeWeak:weak];
        @999 return(ret);
    }
    void wontAddObject:(id)object withIndex:(Unsigned)index {
        @100 [arrayDelegate wontAddObject:object withIndex:index];
    }
    void willAddObject:(id)object withIndex:(Unsigned)index {
        @100 [arrayDelegate willAddObject:object withIndex:index];
    }
    void didAddObject:(id)object withIndex:(Unsigned)index {
        @100 [arrayDelegate didAddObject:object withIndex:index];
    }
    void willRemoveObject:(id)object fromIndex:(Unsigned)index {
        @100 [arrayDelegate willRemoveObject:object fromIndex:index];
    }
    void didRemoveObject:(id)object {
        @100 [arrayDelegate didRemoveObject:object];
    }

    void objectsSwappedWithIndex:(Unsigned)fromIndex andIndex:(Unsigned)toIndex {
        @100 [arrayDelegate objectsSwappedWithIndex:fromIndex andIndex:toIndex];
    }
    void objectsMovedFromRange:(NSRange)fromRange toLocation:(Unsigned)toLocation {
        @100 [arrayDelegate objectsMovedFromRange:fromRange toLocation:toLocation];
    }
    void allObjectsMoved {
        @100 [arrayDelegate allObjectsMoved];
    }
    void stateOK {
        @100 [arrayDelegate stateOK];
    }





<MinimalMutableArray:Array,MutableArrayDelegate,ObjectEquate>
    readonly: NSMutableArray __mutableArray=nil
    CollectionWeakness weakness=
        -v{
            switch (v) {
                case CollectionIsEmpty:[self removeAllObjects];break;
                case CollectionIsWeakAndStrong:default:break;
                case CollectionIsWeak:
                    if (self.weakness&CollectionIsStrong) [self setArray:__array.asWeak];
                    break;
                case CollectionIsStrong:
                    if (self.weakness&CollectionIsWeak) [self setArray:__array.asStrong];
                    break;
            }
        }

    Self start {
        self.delegateForArray=self;
    }

    long version=1
    void stateOK {@-100 version++;}

    void dealloc {@-100 [self removeAllObjects];}

    //Creating a Mutable Array
    id +arrayWithCapacity:(Unsigned)numItems {
        return([[__WIClass__ alloc] initWithCapacity:numItems]);
    }
    Self init {@!-100 __array=__mutableArray=[[NSMutableArray alloc] init];
    }
    Self initWithCoder:(NSCoder*)coder super:init {
        @!-100 __array=__mutableArray=[[NSMutableArray alloc] initWithCoder:coder];
        if (insertsWeakObjectsByDefault) __array=__mutableArray=__array.weakMutableCopy;
    }
    Self initWithArray:(NSArray*)array super:init {
        @!-100 __array=__mutableArray=(insertsWeakObjectsByDefault?array.weakMutableCopy:[[NSMutableArray alloc] initWithArray:array]);
    }
    Self initWithArray:(NSArray*)array copyItems:(BOOL)copy super:init {
        @!-100 __array=__mutableArray=[[NSMutableArray alloc] initWithArray:array copyItems:copy];
        if (insertsWeakObjectsByDefault) __array=__mutableArray=__array.weakMutableCopy;
    }
    Self initWithContentsOfFile:(NSString*)file super:init {
        @!-100 __array=__mutableArray=[[NSMutableArray alloc] initWithContentsOfFile:file];
        if (insertsWeakObjectsByDefault) __array=__mutableArray=__array.weakMutableCopy;
    }
    Self initWithContentsOfURL:(NSURL*)url super:init {
        @!-100 __array=__mutableArray=[[NSMutableArray alloc] initWithContentsOfURL:url];
        if (insertsWeakObjectsByDefault) __array=__mutableArray=__array.weakMutableCopy;
    }
    Self initWithObjects:(id*)objects count:(Unsigned)count super:init {
        @!-100 __array=__mutableArray=[[NSMutableArray alloc] initWithObjects:objects count:count];
        if (insertsWeakObjectsByDefault) __array=__mutableArray=__array.weakMutableCopy;
    }
    Self initWithCapacity:(Unsigned)numItems super:init {
        @-100 __array=__mutableArray=[[NSMutableArray alloc] initWithCapacity:numItems];
        if (insertsWeakObjectsByDefault) __array=__mutableArray=__array.weakMutableCopy;
    }
    
    
    //Adding Objects
    void addObject:(id)object {
        [self insertObject:object atIndex:__mutableArray.count];
    }
    void removeLastObject {
        if (__array.count) [self removeObjectAtIndex:__array.count-1];
    }
    void insertObject:(id)object atIndex:(Unsigned)index {
        if ([self _insertObject:object atIndex:index]) [self stateOK];
    }
    void removeObjectAtIndex:(Unsigned)index {
        if ([self _removeObjectAtIndex:index]) [self stateOK];
    }
    void replaceObjectAtIndex:(Unsigned)index withObject:(id)object {
        if ([self _replaceObjectAtIndex:index withObject:object]) [self stateOK];
    }

    bool _insertObject:(id)object atIndex:(Unsigned)index {
        if (index==NSNotFound) return(NO);
        if (index>__array.count) {
            ERR("%d outside bounds [0,%d]\n",int(index),int(__array.count));
            return(NO);
        }
        [self willTryToAddObjectsWithCount:1];
        bool weak=insertsWeakObjectsByDefault;
        if (![self shouldAddObject:object makeWeak:weak]) [self wontAddObject:object withIndex:index];
        else {
            id useObject;
            if (weak) useObject=[object weakSelf];
            else if (!(useObject=[object strongSelf])) return(NO);

            [self willAddObject:object withIndex:index];

            [__mutableArray insertObject:useObject atIndex:index];
            if (weak) weakObjectCount++;

            if (index!=__array.count) [self objectsMovedFromRange:NSMakeRange(index,__array.countindex+1 ) toLocation:index+1];
            [self didAddObject:object withIndex:index];
            return(YES);
        }
        return(NO);
    }
    bool _removeObjectAtIndex:(Unsigned)index {
        if (index!=NSNotFound) {
            if (index>=__array.count) {
                ERR("%d outside bounds [0,%d)\n",int(index),int(__array.count));
                return(NO);
            }
            NSObject *object=[__array objectAtIndex:index];
            [self willRemoveObjectsWithCount:1];
            [self willRemoveObject:object fromIndex:index];

            if (object.isWeakSelf) --weakObjectCount;
            [__mutableArray removeObjectAtIndex:index];

            [self objectsMovedFromRange:NSMakeRange(index+1,__array.count-index) toLocation:index];
            [self didRemoveObject:object];
            return(YES);
        }
        else return(NO);
    }

    bool _replaceObjectAtIndex:(Unsigned)index withObject:(id)object {
        if (index==NSNotFound) return(NO);
        if (index>=__array.count) {
            ERR("%d outside bounds [0,%d)\n",int(index),int(__array.count));
            return(NO);
        }
        [self willTryToAddObjectsWithCount:1];
        NSObject *object2=[__array objectAtIndex:index];
        if (object==object2) return(NO);
                
        bool weak=insertsWeakObjectsByDefault;
        if (![self shouldAddObject:object makeWeak:weak]) [self wontAddObject:object withIndex:index];
        else {
            id useObject;
            if (weak) useObject=[object weakSelf];
            else if (!(useObject=[object strongSelf])) return(NO);


            [self willRemoveObjectsWithCount:1];
            [self willRemoveObject:object2 fromIndex:index];

            if (object2.isWeakSelf) --weakObjectCount;
            [__mutableArray removeObjectAtIndex:index];

            [self didRemoveObject:object2];

            [self willAddObject:object withIndex:index];

            [__mutableArray insertObject:useObject atIndex:index];
            if (weak) weakObjectCount++;

            [self didAddObject:object withIndex:index];
            return(YES);
        }
        return(NO);
    }







<MutableArray:MinimalMutableArray>
    void insertObjects:(NSArray*)objects atIndexes:(NSIndexSet*)indexes {
        if ([self _insertObjects:objects atIndexes:indexes]) [self stateOK];
    }
    void addObjectsFromArray:(NSArray*)array {
        if ([self _addObjectsFromArray:array]) [self stateOK];
    }
    void removeAllObjects {
        if ([self _removeAllObjects]) [self stateOK];
    }
    void removeObjectsAtIndexes:(NSIndexSet*)indexes {
        if ([self _removeObjectsAtIndexes:indexes]) [self stateOK];
    }


    bool _addObjectsFromArray:(NSArray*)array {
        if (array.count) {
            Unsigned cwas=__array.count,added=0;
            [self willTryToAddObjectsWithCount:array.count];
            for (NSObject *object in array) {
                bool weak=insertsWeakObjectsByDefault;
                if (![self shouldAddObject:object makeWeak:weak]) [self wontAddObject:object withIndex:cwas+added];
                else {
                    id useObject;
                    if (weak) useObject=[object weakSelf];
                    else if (!(useObject=[object strongSelf])) continue;

                    [self willAddObject:object withIndex:cwas+added];
                    
                    [__mutableArray addObject:useObject];
                    if (weak) weakObjectCount++;

                    [self didAddObject:object withIndex:cwas+added];
                    added++;
                }
            }
            return(added>0);
        }
        else return(NO);
    }
    bool _insertObjects:(NSArray*)objects atIndexes:(NSIndexSet*)indexes {
        bool ret=NO;
        if (objects.count!=indexes.count) {
            ERR("Bad count");
            return(NO);
        }
        Unsigned skipped=0,move=0,index=[indexes firstIndex],prvIndex;

        NSMutableIndexSet *addedInds=[[NSMutableIndexSet alloc] init];
        
        [self willTryToAddObjectsWithCount:objects.count];
        for (NSObject *object in objects) {
            bool weak=insertsWeakObjectsByDefault;
            if (![self shouldAddObject:object makeWeak:weak]) {
                [self wontAddObject:object withIndex:index];
                skipped++;
            }
            else do {
                id useObject;
                if (weak) useObject=[object weakSelf];
                else if (!(useObject=[object strongSelf])) break;

                [addedInds addIndex:index];
                [self willAddObject:object withIndex:index-skipped];
                
                [__mutableArray insertObject:useObject atIndex:index-skipped];
                if (weak) weakObjectCount++;
                move++;
            } while(NO);
            index=[indexes indexGreaterThanIndex:index];
        }
        if (move) {
            for (prvIndex=__mutableArray.count+indexes.count-skipped,index=indexes.lastIndex;index!=NSNotFound;index=[indexes indexLessThanIndex:index]) {
                if ([addedInds containsIndex:index]) {
                    [self objectsMovedFromRange:NSMakeRange(index-skipped,prvIndexindex-skipped ) toLocation:(index-skipped)+move];
                    prvIndex=index-skipped;
                    move--;
                }
                else skipped--;
            }

            index=indexes.firstIndex;
            for (NSObject *object in objects) {
                if ([addedInds containsIndex:index]) {
                    [self didAddObject:object withIndex:index-skipped];
                }
                else skipped++;
            }
            ret=YES;
        }
        return(ret);
    }
    
    
    //Removing Objects
    bool _removeAllObjects {
        if (!self.count) return(NO);
        NSArray *was=[__array copy];
        [self willRemoveObjectsWithCount:was.count];
        for (Int i=int(was.count)-1;i>=0;i--) {
            [self willRemoveObject:[was objectAtIndex:i] fromIndex:i];
        }
        [__mutableArray removeAllObjects];
        weakObjectCount=0;

        for (NSObject *object in was) [self didRemoveObject:object];
        return(YES);
    }

    /*void removeObject:(id)object {
        Int i=0,oi=NSNotFound,weakRemovalCount=0;
        NSMutableArray *toRemove=nil;
        for (NSObject *object2 in self) {
            if ([object2 isEqual:object]) {
                oi=i;
                [self willRemoveObject:object2 fromIndex:i];
                if (!toRemove) toRemove=[[NSMutableArray alloc] initWithCapacity:self.count];
                [toRemove addObject:object2];
                if (object2.isWeakSelf) weakRemovalCount++;
            }
            i++;
        }
        if (toRemove) {
            [__mutableArray removeObject:object];
            weakObjectCount-=weakRemovalCount;

            for (NSObject *object2 in toRemove) [self didRemoveObject:object2];
            if (toRemove.count==1) [self objectsMovedFromRange:NSMakeRange(oi+1,__array.count-oi) toLocation:oi];
            else [self allObjectsMoved];
        }
        [self stateOK];
    }*/
    /*void removeObject:(id)object inRange:(NSRange)r {
        Int i=0,oi=NSNotFound,weakRemovalCount=0;
        NSMutableArray *toRemove=nil;
        for (NSObject *object2 in self) {
            if (i>=r.location) {
                if (i>=r.location+r.length) break;
                if ([object2 isEqual:object]) {
                    oi=i;
                    [self willRemoveObject:object2 fromIndex:i];
                    if (!toRemove) toRemove=[[NSMutableArray alloc] initWithCapacity:self.count];
                    [toRemove addObject:object2];
                    if (object2.isWeakSelf) weakRemovalCount++;
                }
            }
            i++;
        }
        if (toRemove) {
            [__mutableArray removeObject:object inRange:r];
            weakObjectCount-=weakRemovalCount;

            for (NSObject *object2 in toRemove) [self didRemoveObject:object2];
            if (toRemove.count==1) [self objectsMovedFromRange:NSMakeRange(oi+1,__array.count-oi) toLocation:oi];
            else [self allObjectsMoved];
        }
        [self stateOK];
    }*/

    bool _removeObjectsAtIndexes:(NSIndexSet*)indexes {
        [self willRemoveObjectsWithCount:indexes.count];
        for (Unsigned index=[indexes lastIndex];index!=NSNotFound;index=[indexes indexLessThanIndex:index]) {
            NSObject *object=[__array objectAtIndex:index];
            [self willRemoveObject:object fromIndex:index];

            [__mutableArray removeObjectAtIndex:index];
            if (object.isWeakSelf) --weakObjectCount;

            [self didRemoveObject:object];
        }
        for (Unsigned index=[indexes firstIndex],i=0;index!=NSNotFound;index=[indexes indexGreaterThanIndex:index],i++) {
            Unsigned nxtIndex=[indexes indexGreaterThanIndex:index];
            if (nxtIndex==NSNotFound) nxtIndex=__mutableArray.count+indexes.count;
            if (nxtIndex>index+1) [self objectsMovedFromRange:NSMakeRange(index+1,nxtIndexindex+1 ) toLocation:index-i];
        }
        return(indexes.count>0);
    }
    /*void removeObjectIdenticalTo:(id)object {
        Int i=0,c=0,oi=NSNotFound;
        for (NSObject *object2 in __array) {
            if (object2==object) {
                oi=i;
                [self willRemoveObject:object fromIndex:i];
                c++;
            }
            i++;
        }
        [__mutableArray removeObjectIdenticalTo:object];
        if (object.isWeakSelf) weakObjectCount-=c;

        for (Int cc=0;cc<c;cc++) [self didRemoveObject:object];
        if (c==1) [self objectsMovedFromRange:NSMakeRange(oi+1,__array.count-oi) toLocation:oi];
        else [self allObjectsMoved];
        [self stateOK];
    }*/
    /*void removeObjectIdenticalTo:(id)object inRange:(NSRange)r {
        Int i=0,c=0,oi=NSNotFound;
        for (NSObject *object2 in __array) {
            if (i>=r.location) {
                if (i>=r.location+r.length) break;
                if (object2==object) {
                    oi=i;
                    [self willRemoveObject:object fromIndex:i];
                    c++;
                }
            }
            i++;
        }
        [__mutableArray removeObjectIdenticalTo:object inRange:r];
        if (object.isWeakSelf) weakObjectCount-=c;

        for (Int cc=0;cc<c;cc++) [self didRemoveObject:object];
        if (c==1) [self objectsMovedFromRange:NSMakeRange(oi+1,__array.count-oi) toLocation:oi];
        else [self allObjectsMoved];
        [self stateOK];
    }*/
    /*void removeObjectsInArray:(NSArray*)array {
        for (NSObject *object in array) [self removeObject:object];
    }*/
    /*void removeObjectsInRange:(NSRange)r {
        for (Int i=((int)r.length)-1;i>=0;i--) {
            NSObject *object=[__array objectAtIndex:r.location+i];
            [self willRemoveObject:object fromIndex:r.location+i];

            [__mutableArray removeObjectAtIndex:r.location+i];
            if (object.isWeakSelf) --weakObjectCount;

            [self didRemoveObject:object];
        }
        [self objectsMovedFromRange:NSMakeRange(r.location+r.length,__array.count-r.location) toLocation:r.location];
        [self stateOK];
    }*/
    
    
    //Replacing Objects
    /*void replaceObjectsAtIndexes:(NSIndexSet*)indexes withObjects:(NSArray*)array {
        Unsigned index=[indexes firstIndex];
        for (NSObject *object in array) {
            [self replaceObjectAtIndex:index withObject:object];
            index=[indexes indexGreaterThanIndex:index];
        }
        [self stateOK];
    }*/
    /*void replaceObjectsInRange:(NSRange)r withObjectsFromArray:(NSArray*)array range:(NSRange)arrayRange {
        NSIndexSet *inss,*dels;
        NSMutableArray *subArray=[[NSMutableArray alloc] initWithCapacity:r.length];
        for (Unsigned i=r.location;i<r.location+r.length;i++) [subArray addObject:[__array objectAtIndex:i]];
        NSMutableArray *asubArray=[[NSMutableArray alloc] initWithCapacity:arrayRange.length];
        for (Unsigned i=arrayRange.location;i<arrayRange.location+arrayRange.length;i++) [asubArray addObject:[array objectAtIndex:i]];
        bool __changed=[Util getInsertsAndDeletesAsIndexSetWhenChanging:subArray to:asubArray inss:&inss dels:&dels];
        if (!__changed) return;
        if (r.location) {
            NSMutableIndexSet *indexes=dels.mutableCopy;
            [indexes shiftIndexesStartingAtIndex:0 by:r.location];
            dels=indexes;
        }
        [self removeObjectsAtIndexes:dels];
        for (Unsigned index=inss.firstIndex;index!=NSNotFound;index=[inss indexGreaterThanIndex:index]) {
            [self insertObject:[array objectAtIndex:index+arrayRange.location] atIndex:index+r.location];
        }
        [self allObjectsMoved];        
        [self stateOK];
    }*/
    /*void replaceObjectsInRange:(NSRange)r withObjectsFromArray:(NSArray*)array {
        NSIndexSet *inss,*dels;
        NSMutableArray *subArray=[[NSMutableArray alloc] initWithCapacity:r.length];
        for (Unsigned i=r.location;i<r.location+r.length;i++) [subArray addObject:[__array objectAtIndex:i]];
        bool __changed=[Util getInsertsAndDeletesAsIndexSetWhenChanging:subArray to:array inss:&inss dels:&dels];
        if (!__changed) return;
        if (r.location) {
            NSMutableIndexSet *indexes=dels.mutableCopy;
            [indexes shiftIndexesStartingAtIndex:0 by:r.location];
            dels=indexes;
        }
        [self removeObjectsAtIndexes:dels];
        for (Unsigned index=inss.firstIndex;index!=NSNotFound;index=[inss indexGreaterThanIndex:index]) {
            [self insertObject:[array objectAtIndex:index] atIndex:index+r.location];
        }
        [self allObjectsMoved];
        [self stateOK];
    }*/



    void setArray:(NSArray*)array {
        NSIndexSet *inss,*dels;
        if (![Util getInsertsAndDeletesAsIndexSetWhenChanging:__array to:array inss:&inss dels:&dels]) return;
        [self _removeObjectsAtIndexes:dels];
        NSArray *objs=[array objectsAtIndexes:inss];
        [self _insertObjects:objs atIndexes:inss];
        [self stateOK];
    }
    
    
    //Filtering Content
    void filterUsingPredicate:(NSPredicate *)predicate {
        NSMutableIndexSet *toRemove=nil;
        Unsigned index=0;
        for (NSObject *object in __array) {
            if (![predicate evaluateWithObject:object]) {
                if (!toRemove) toRemove=[[NSMutableIndexSet alloc] init];
                [toRemove addIndex:index];
            }
            index++;
        }
        if (toRemove) {
            [self _removeObjectsAtIndexes:toRemove];
            [self stateOK];
        }
    }
    
    
    //Rearranging Content
    void exchangeObjectAtIndex:(Unsigned)fromi withObjectAtIndex:(Unsigned)toi {
        if (fromi!=toi) {
            [__mutableArray exchangeObjectAtIndex:fromi withObjectAtIndex:toi];
            [self objectsSwappedWithIndex:fromi andIndex:toi];
            [self stateOK];
        }
    }
    void sortUsingDescriptors:(NSArray*)sortDescriptors {
        [__mutableArray sortUsingDescriptors:sortDescriptors];
        [self allObjectsMoved];
        [self stateOK];
    }
    void sortUsingComparator:(NSComparator)cmptr {
        [__mutableArray sortUsingComparator:cmptr];
        [self allObjectsMoved];
        [self stateOK];
    }
    void sortWithOptions:(NSSortOptions)opts usingComparator:(NSComparator)cmptr {
        [__mutableArray sortWithOptions:opts usingComparator:cmptr];
        [self allObjectsMoved];
        [self stateOK];
    }
    void sortUsingFunction:(Int (*)(id, id, void *))compare context:(void *)context {
        [__mutableArray sortUsingFunction:compare context:context];
        [self allObjectsMoved];
        [self stateOK];
    }
    void sortUsingSelector:(SEL)selector {
        [__mutableArray sortUsingSelector:selector];
        [self allObjectsMoved];
        [self stateOK];
    }








<ModelMutableArray>
    bool shouldAddObject:(id)object makeWeak:(bool&)weak {
        if (![object conformsToProtocol:@protocol(RefCountedObject)]) ret=NO;
    }
    void didAddObject:(id)object withIndex:(Unsigned)index {
        [object modeladd];
    }
    void willRemoveObject:(id)object fromIndex:(Unsigned)index {
        [object modelsub];
    }
    



<NotifiedByArray>
    void markDirtyByArray {[self markDirty];}
    void markDirty {}

<NotifyingMutableArray>
    notifyingArray -s< <NotifiedByArray> arrayWatcher

    void stateOK {@100 
        for (NSObject<NotifiedByArray>*w in self.arrayWatchers) {
            [w markDirtyByArray];
        }
    }










<MutableArrayIndexFollower:BasicTester>
    NSMutableDictionary __arrayObjectIndexes=[NSMutableDictionary dictionary] (ivar=__arrayObjectIndexes)
    

    void didAddObject:(id)object withIndex:(Unsigned)index {@-950 
        //[self objectsMovedFromRange:NSMakeRange(index,__array.count-1-index) toLocation:index+1];
        [self doAddIndex:index forObject:object];
    }
    void willRemoveObject:(id)object fromIndex:(Unsigned)index {@950 
        [self doRemoveIndex:index forObject:object];
        //[self objectsMovedFromRange:NSMakeRange(index+1,__array.count-1-index) toLocation:index];
    }
    void objectsSwappedWithIndex:(Unsigned)fromIndex andIndex:(Unsigned)toIndex {
        NSObject *object1=[__array objectAtIndex:toIndex];
        NSObject *object2=[__array objectAtIndex:fromIndex];
        if (object1!=object2) {
            [self doChangeIndex:fromIndex toIndex:toIndex forObject:object1];
            [self doChangeIndex:toIndex toIndex:fromIndex forObject:object2];
        }
    }
    void objectsMovedFromRange:(NSRange)fromRange toLocation:(Unsigned)toLocation {
        for (Unsigned i=0;i<fromRange.length;i++) {
            Unsigned j=(toLocation>fromRange.location?fromRange.length-1-i:i);
            NSObject *object=[__array objectAtIndex:toLocation+j];
            [self doChangeIndex:fromRange.location+j toIndex:toLocation+j forObject:object];
        }
    }
    void allObjectsMoved {
        [__arrayObjectIndexes removeAllObjects];
        Unsigned index=0;
        for (NSObject *object in __array) {
            [self doAddIndex:index++ forObject:object];
        }
    }
    
    
    void doAddIndex:(Unsigned)index forObject:(id)object {
        NSMutableIndexSet *indexes=[__arrayObjectIndexes objectForKey:(id<NSCopying>)object];
        if (!indexes) [__arrayObjectIndexes setObject:indexes=[NSMutableIndexSet indexSet] forWeakKey:object];
        else if ([indexes containsIndex:index]) {[self passFail:NO format:@"!!!ai Index exists\n"];ERR("a");}
        [indexes addIndex:index];
    }
    void doRemoveIndex:(Unsigned)index forObject:(id)object {
        NSMutableIndexSet *indexes=[__arrayObjectIndexes objectForKey:(id<NSCopying>)object];
        if (!indexes) {[self passFail:NO format:@"!!!ai Object not known\n"];ERR("a");}
        if (![indexes containsIndex:index]) {[self passFail:NO format:@"!!!ai Index doesn't exist\n"];ERR("a");}
        if (indexes.count==1) [__arrayObjectIndexes removeObjectForKey:(id<NSCopying>)object];
        else [indexes removeIndex:index];
    }
    void doChangeIndex:(Unsigned)fromIndex toIndex:(Unsigned)toIndex forObject:(id)object {
        NSMutableIndexSet *indexes=[__arrayObjectIndexes objectForKey:(id<NSCopying>)object];
        if (!indexes) {[self passFail:NO format:@"!!!ai Object not known (2)\n"];ERR("a");}
        if (![indexes containsIndex:fromIndex]) {[self passFail:NO format:@"!!!ai Index doesn't exist (2)\n"];ERR("a");}
        [indexes removeIndex:fromIndex];
        if ([indexes containsIndex:toIndex]) {[self passFail:NO format:@"!!!ai Index exists (2)\n"];ERR("a");}
        [indexes addIndex:toIndex];
    }








